<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-10T14:25:56.745Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[17.18. 最短超串]]></title>
        <id>https://oneseek.github.io/post/1718-zui-duan-chao-chuan/</id>
        <link href="https://oneseek.github.io/post/1718-zui-duan-chao-chuan/">
        </link>
        <updated>2020-04-10T14:22:11.000Z</updated>
        <content type="html"><![CDATA[<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<p>示例 1:</p>
<p>输入:<br>
big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]<br>
small = [1,5,9]<br>
输出: [7,10]<br>
示例 2:</p>
<p>输入:<br>
big = [1,2,3]<br>
small = [4]<br>
输出: []<br>
提示：</p>
<p>big.length &lt;= 100000<br>
1 &lt;= small.length &lt;= 100000</p>
<pre><code>class Solution {
    public int[] shortestSeq(int[] big,int[] small) {
        if(small.length&gt;big.length){ //small长度大于big的情况
            return new int[0];
        }
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        int count = small.length;
        int[] ans = {0,big.length};

        for(int i:small){
            map.put(i, -1);
        }

        for(int i=0;i&lt;big.length;i++){
            if(map.containsKey(big[i])){
                if(map.get(big[i])==-1){
                    count--;
                }
                map.put(big[i], i);
            }
            if(count&lt;=0){
                Object[] objects =  map.values().toArray();
                int minNum = getMin(objects);
                if(i-minNum+1&lt;ans[1]-ans[0]+1){
                    ans[0]=minNum;
                    ans[1]=i;
                }
            }
            if(count&gt;0&amp;&amp;big.length-1==i){ // 查找不到超短字串的情况
                ans=new int[0];
            }
        }

        return ans;
    }

    int getMin(Object[] obj) {
        int minNum = Integer.MAX_VALUE;
        for(Object i:obj){
            minNum=Math.min((int)i, minNum);
        }
        return minNum;
    }
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/chao-xiang-xi-jie-fa-yi-ding-neng-kan-dong-by-yuan/">题目链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode 945. 使数组唯一的最小增量]]></title>
        <id>https://oneseek.github.io/post/leetcode-945-shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang/</id>
        <link href="https://oneseek.github.io/post/leetcode-945-shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang/">
        </link>
        <updated>2020-04-08T14:41:22.000Z</updated>
        <content type="html"><![CDATA[<p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
<p>示例 1:</p>
<p>输入：[1,2,2]<br>
输出：1<br>
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。<br>
示例 2:</p>
<p>输入：[3,2,1,2,1,7]<br>
输出：6<br>
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。<br>
提示：</p>
<p>0 &lt;= A.length &lt;= 40000<br>
0 &lt;= A[i] &lt; 40000</p>
<p>思路：先排序，再去重复</p>
<pre><code>class Solution {
    public int minIncrementForUnique(int[] A) {
        int ans = 0;
        Arrays.sort(A);  
        for(int i=1;i&lt;A.length;i++){
            if(A[i]&lt;=A[i-1]){
                ans += A[i-1]+1-A[i];
                A[i]=A[i-1]+1;
            }
        }
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 创建对象的几种方法]]></title>
        <id>https://oneseek.github.io/post/java-chuang-jian-dui-xiang-de-ji-chong-fang-fa/</id>
        <link href="https://oneseek.github.io/post/java-chuang-jian-dui-xiang-de-ji-chong-fang-fa/">
        </link>
        <updated>2020-04-06T03:11:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="正向">正向</h1>
<p>通过 new</p>
<h1 id="反向-反射">反向 -- 反射</h1>
<p>newInstant()<br>
使用Class类的newInstance方法<br>
使用Constructor类的newInstance方法</p>
<h1 id="clone">clone</h1>
<pre><code> implements Cloneable
</code></pre>
<h1 id="序列化">序列化</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java实现多线程的三种方法]]></title>
        <id>https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/</id>
        <link href="https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/">
        </link>
        <updated>2020-04-06T02:53:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一种-继承-thread类">第一种 继承 Thread类</h2>
<pre><code> 继承Thread类，并重写Thread中的run方法
</code></pre>
<pre><code>class MyThread extends Thread{
　　@Override
　　public void run(){
 　　　　System.out.println(&quot;创建多线程方法一&quot;);
　　}
}
</code></pre>
<h2 id="第二种-实现-runable接口">第二种 实现 Runable接口</h2>
<pre><code>      实现Runnable接口，重写run()方法
</code></pre>
<pre><code>class MyThread implements Runnable{
     @Override
     public void run(){
         System.out.println(&quot;创建多线程方法二&quot;);
     }
}
</code></pre>
<h2 id="第三种-实现callable接口">第三种 实现Callable接口</h2>
<pre><code>      实现Callable接口，重写call()方法
      可以提供返回值 可以抛出异常
      创建Callable实现类
      创建线程池 submi Callable实现类t
</code></pre>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见关系数据库和非关系数据库]]></title>
        <id>https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/</id>
        <link href="https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/">
        </link>
        <updated>2020-04-06T02:52:33.000Z</updated>
        <content type="html"><![CDATA[<p>​关系数据库 ：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL</p>
<p>​非关系数据库：NoSql、Cloudant、MongoDb、redis、HBase</p>
]]></content>
    </entry>
</feed>