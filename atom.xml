<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-11T13:27:55.649Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[算法训练-1的个数]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-1-de-ge-shu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-1-de-ge-shu/">
        </link>
        <updated>2020-03-11T13:26:27.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 1的个数
  
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
　　输入正整数n，判断从1到n之中，数字1一共要出现几次。例如1123这个数，则出现了两次1。例如15，那么从1到15之中，一共出现了8个1。
输入格式
　　一个正整数n
输出格式
　　一个整数，表示1出现的资料
样例输入
15
样例输出
8
数据规模和约定
　　n不超过30000
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int cal(int n){
	int sum=0;
	while(n){
		if(n%10==1){
			sum++;
		}
		n/=10;
	}
	return sum;
} 
int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
	int sum=0;
	for(int i=1;i&lt;=n;i++){
		sum+=cal(i);
	}
	printf(&quot;%d&quot;,sum);
    return 0;
}
</code></pre>
<h3 id="水题刷着好开心啊o-̄-̄ブ">水题刷着好开心啊o(<em>￣▽￣</em>)ブ</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-二进制数数]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-er-jin-zhi-shu-shu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-er-jin-zhi-shu-shu/">
        </link>
        <updated>2020-03-11T13:18:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 二进制数数
  
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
　　给定L,R。统计[L,R]区间内的所有数在二进制下包含的“1”的个数之和。
　　如5的二进制为101，包含2个“1”。
输入格式
　　第一行包含2个数L,R
输出格式
　　一个数S，表示[L,R]区间内的所有数在二进制下包含的“1”的个数之和。
样例输入
2 3
样例输出
3
数据规模和约定
　　L&lt;=R&lt;=100000;
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int cal(int a){
	int sum=0;
	while(a){
		if(a%2){
			sum++;
		}
		a/=2;
	}
	return sum;
} 
int main() {
    int L,R;
    scanf(&quot;%d%d&quot;,&amp;L,&amp;R);
	int sum=0;
	for(int i=L;i&lt;=R;i++){
		sum+=cal(i);
	}
	printf(&quot;%d&quot;,sum);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-交换(水~)]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-jiao-huan-shui-~/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-jiao-huan-shui-~/">
        </link>
        <updated>2020-03-11T13:09:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 数据交换
  
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
　　编写一个程序，输入两个整数，分别存放在变量x和y当中，然后使用自己定义的函数swap来交换这两个变量的值。
　　输入格式：输入只有一行，包括两个整数。
　　输出格式：输出只有一行，也是两个整数，即交换以后的结果。
　　要求：主函数负责数据的输入与输出，但不能直接交换这两个变量的值，必须通过调用单独定义的函数swap来完成，而swap函数只负责交换变量的值，不能输出交换后的结果。
输入输出样例
样例输入
4 7
样例输出
7 4
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
void swap(int* a,int* b){
	int x;
	x = *a;
	*a = *b;
	*b = x;
} 
int main() {
    int a,b;
    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
    swap(&amp;a,&amp;b);
    printf(&quot;%d %d&quot;,a,b);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-K好数]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-k-hao-shu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-k-hao-shu/">
        </link>
        <updated>2020-03-11T13:04:24.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 K好数

资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。
求L位K进制数中K好数的数目。例如K = 4，L =
2的时候，所有K好数为11、13、20、22、30、31、33 共7个。
由于这个数目很大，请你输出它对1000000007取模后的值。

输入格式
输入包含两个正整数，K和L。

输出格式
输出一个整数，表示答案对1000000007取模后的值。
样例输入
4 2
样例输出
7
数据规模与约定
对于30%的数据，KL &lt;= 106；

对于50%的数据，K &lt;= 16， L &lt;= 10；

对于100%的数据，1 &lt;= K,L &lt;= 100。
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int main() {
    int k, l;
    scanf(&quot;%d%d&quot;, &amp;k, &amp;l);
    // l位k进制中k好数的数目
    // 最大数是k-1 l个数
    long long arr[l + 1][k + 1];
    memset(arr, 0, sizeof(arr));
    for (int i = 0; i &lt;= k - 1; i++) {
        arr[1][i] = 1;  // i开头
    }

    for (int i = 2; i &lt;= l; i++) {
        for (int j = 0; j &lt;= k - 1; j++) {
            for (int m = 0; m &lt;= k - 1; m++) {
                if (abs(j - m) &gt; 1 || j == m) {
                    // i开头的j进制数的个数 arr[i][j] = a[i-1][1...k-1](除了j-1,j+1)
                    arr[i][j] += arr[i - 1][m] % 1000000007;
                }
            }
        }
    }

    long long res = 0;
    for (int i = 1; i &lt;= k - 1; i++) { // 把最后一行加起来 
        res += arr[l][i];
        res %= 1000000007;
    }
    printf(&quot;%lld&quot;, res);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-最短路(BF)]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-zui-duan-lu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-zui-duan-lu/">
        </link>
        <updated>2020-03-06T08:17:33.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 最短路
  
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
给定一个n个顶点，m条边的有向图（其中某些边权可能为负，但保证没有负环）。
请你计算从1号点到其他点的最短路（顶点从1到n编号）。

输入格式
第一行两个整数n, m。

接下来的m行，每行有三个整数u, v, l，表示u到v有一条长度为l的边。

输出格式
共n-1行，第i行表示1号点到i+1号点的最短路。
样例输入
3 3
1 2 -1
2 3 -1
3 1 2
样例输出
-1
-2
数据规模与约定
对于10%的数据，n = 2，m = 2。

对于30%的数据，n &lt;= 5，m &lt;= 10。

对于100%的数据，1 &lt;= n &lt;= 20000，1 &lt;= m &lt;= 200000，
-10000 &lt;= l &lt;= 10000，保证从任意顶点都能到达其他所有顶点。
*/
#include&lt;cstdio&gt;
#include&lt;vector&gt;
using namespace std;
struct Node{
    int v;
    int dis;
    Node(int _v,int _dis){
        v = _v;
        dis = _dis;
    }
};
vector&lt;Node&gt; Adj[20001];
#define maxL (1 &lt;&lt; 30)
int main(){
    int n, m;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
   
    for (int i = 1; i &lt;= m; i++){
        int u, v, l;
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;l);
        Node node = Node(v, l);
        Adj[u].push_back(node);
    }
    int d[20001];
    fill(d, d + 20001, maxL);
    d[1] = 0;
    bool update;
    while (true){
        update = false;
        for (int i = 1; i &lt;= n; i++){
            for (int j = 0; j &lt; Adj[i].size(); j++){
                int v = Adj[i][j].v;
                int dis = Adj[i][j].dis;
                if (d[i] + dis &lt; d[v]){
                    d[v] = d[i] + dis;
                    update = true;
                }
            }
        }
        if(!update){
            break;
        }
    }

    for (int i = 2; i &lt;= n; i++){
        printf(&quot;%d\n&quot;, d[i]);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[水题-大小写转换]]></title>
        <id>https://oneseek.github.io/post/shui-ti-da-xiao-xie-zhuan-huan/</id>
        <link href="https://oneseek.github.io/post/shui-ti-da-xiao-xie-zhuan-huan/">
        </link>
        <updated>2020-03-02T12:29:41.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 大小写转换
  
资源限制
时间限制：1.0s   内存限制：512.0MB
问题描述
　　编写一个程序，输入一个字符串（长度不超过20），然后把这个字符串内的每一个字符进行大小写变换，即将大写字母变成小写，小写字母变成大写，然后把这个新的字符串输出。
　　输入格式：输入一个字符串，而且这个字符串当中只包含英文字母，不包含其他类型的字符，也没有空格。
　　输出格式：输出经过转换后的字符串。
输入输出样例
样例输入
AeDb
样例输出
aEdB
*/
#include&lt;cstdio&gt;
int main(){
    char s[20];
    scanf(&quot;%s&quot;, &amp;s);
    int l = 'a' - 'A';
    for (int i = 0; s[i]!=NULL; i++){
        if(s[i]&gt;='a'){
            s[i] -= l;
        }else{
            s[i] += l;
        }
        printf(&quot;%c&quot;, s[i]);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置gitalk]]></title>
        <id>https://oneseek.github.io/post/pei-zhi-gitalk/</id>
        <link href="https://oneseek.github.io/post/pei-zhi-gitalk/">
        </link>
        <updated>2020-03-02T08:43:01.000Z</updated>
        <content type="html"><![CDATA[<p>开始遇到一点小麻烦http和https设置的有点混乱 出现加载问题 都设置成https就ok了 开始一直不行原来是因为没清缓存😤</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[十六进制转八进制]]></title>
        <id>https://oneseek.github.io/post/shi-liu-jin-zhi-zhuan-ba-jin-zhi/</id>
        <link href="https://oneseek.github.io/post/shi-liu-jin-zhi-zhuan-ba-jin-zhi/">
        </link>
        <updated>2020-02-29T16:28:44.000Z</updated>
        <content type="html"><![CDATA[<p>数组开的太大 会数据异常</p>
<p>数组开到400000时 在自己的电脑上无法运行 但是可以通过成功AC</p>
<p>原因：<br>
感觉应该是和内存有关系，试了试在腾讯云的服务器上运行可以正常运行，可能是电脑的内存限制或编译设置之类的</p>
<pre><code>/*
试题 基础练习 十六进制转八进制
  
资源限制
时间限制：1.0s   内存限制：512.0MB
问题描述
　　给定n个十六进制正整数，输出它们对应的八进制数。

输入格式
　　输入的第一行为一个正整数n （1&lt;=n&lt;=10）。
　　接下来n行，每行一个由0~9、大写字母A~F组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。

输出格式
　　输出n行，每行为输入对应的八进制正整数。

　　【注意】
　　输入的十六进制数不会有前导0，比如012A。
　　输出的八进制数也不能有前导0。

样例输入
　　2
　　39
　　123ABC

样例输出
　　71
　　4435274

　　【提示】
　　先将十六进制数转换成某进制数，再由某进制数转换成八进制。

*/

#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
using namespace std;

void convert16from2to8(char s[100002]){
    if(strcmp(s,&quot;0&quot;)==0){
        printf(&quot;%c\n&quot;, '0');
        return;
    }
    int s_len = strlen(s); // 十六进制数的长度
    int er[400008]={0}; // 先转换二进制数
    int l = 0;
    for (int i = 0; i &lt; s_len; i++,l+=4){
        int temp=0; // 十六进制数每位的十进制表示
        if(s[i]&gt;='A'){
            temp = s[i] - 'A' + 10;
        }else{
            temp = s[i] - '0';
        }

        int j = 4;  
        while(j--){ // 转换成二进制数
            er[l+j] = temp % 2;
            temp /= 2;
        }   
    }

    int eight[200004] = {0}; // 八进制数
    int el = 0; // 八位数的长度记录
    for (int i = l-1; i &gt;=0 ; ){
        int j = 3;
        int e = 0;
        while(j--){
            // eight[el] += er[i] * pow(2, 2-j);
            e += er[i] * pow(2, 2-j);
            i--;
            if(i&lt;0){
                break;
            }
        }
        eight[el++] = e;
    }


    while(eight[el]==0){
        el--;
    }
    
    for (int i = el ; i &gt;= 0; i--){
        printf(&quot;%d&quot;, eight[i]);
    }
    printf(&quot;\n&quot;);

}
int main(){
    int n;
    scanf(&quot;%d&quot;, &amp;n);

    for (int i = 0; i &lt; n;i++){
        char s[100002]={0};
        scanf(&quot;%s&quot;, s); // 输入十六进制数

        convert16from2to8(s);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阶乘计算（高精度）]]></title>
        <id>https://oneseek.github.io/post/jie-cheng-ji-suan-gao-jing-du/</id>
        <link href="https://oneseek.github.io/post/jie-cheng-ji-suan-gao-jing-du/">
        </link>
        <updated>2020-02-29T13:24:39.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 基础练习 阶乘计算
  
资源限制
时间限制：1.0s   内存限制：512.0MB
问题描述
　　输入一个正整数n，输出n!的值。
　　其中n!=1*2*3*…*n。
算法描述
　　n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。
　　将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。
　　首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。
输入格式
　　输入包含一个正整数n，n&lt;=1000。
输出格式
　　输出n!的准确值。
样例输入
10
样例输出
3628800
*/
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define N 3000
int main(){
    int n;
    scanf(&quot;%d&quot;, &amp;n);

    int a[N];
    a[1] = 1;
    int i, j;
    int q=1 , carry;
    int temp;
    for (i = 2; i &lt;= n; i++){
        carry = 0;
        for (j = 1; j &lt;= q; j++){
            temp = a[j] * i + carry;
            a[j] = temp % 10;
            carry = temp / 10;
        }
        while(carry){
            a[++q] = carry % 10;
            carry = carry / 10;
        }
    }
    for (i = q; i &gt; 0;i--){
        printf(&quot;%d&quot;, a[i]);
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://oneseek.github.io/post/hello-gridea/</id>
        <link href="https://oneseek.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>