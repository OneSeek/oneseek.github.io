<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-15T15:16:15.126Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[疫情地图在线训练营]]></title>
        <id>https://oneseek.github.io/post/yi-qing-di-tu-zai-xian-xun-lian-ying/</id>
        <link href="https://oneseek.github.io/post/yi-qing-di-tu-zai-xian-xun-lian-ying/">
        </link>
        <updated>2020-04-15T13:01:41.000Z</updated>
        <summary type="html"><![CDATA[<p>疫情地图公众号训练<br>
导图</p>
<p>任务卡</p>
<p>Day01<br>
关机小程序<br>
自动关机</p>
<p>取消自动关机</p>
<pre><code>import java.io.IOException;
import java.util.Scanner;

public class Demo1 {

   public static void main(String[] args) throws IOException{
   	// TODO Auto-generated method stub
   	while(true) {
   		Scanner scanner = new Scanner(System.in);
   		System.out.println(&quot;关机请输入:1, \t取消关机请输入:2, \t退出请输入3!&quot;);
   		System.out.println(&quot;****************************************************&quot;);
   		String select = scanner.next();
   		if(select.equals(&quot;1&quot;)) {
   			System.out.println(&quot;请输入关机秒数，例如3600:&quot;);
   			String time = scanner.next();
   			Runtime.getRuntime().exec(&quot;shutdown -s -t &quot;+time);
   			//System.out.println(&quot;shutdown -s -t &quot;+time);
   			System.out.println(time+&quot;秒后关机&quot;);
   		}else if(select.equals(&quot;2&quot;)) {
   			Runtime.getRuntime().exec(&quot;shutdown -a&quot;);
   			System.out.println(&quot;已取消关机\n&quot;);
   		}else if(select.equals(&quot;3&quot;)){
   			break;
   		}else {
   			System.out.println(&quot;输入错误，请重新输入！&quot;);
   		}
   	}
   }

}
</code></pre>
<p>Day02<br>
今日任务：验证码短信发送<br>
任务线索：<br>
1、URL类（URL、URLConnection、参数传递、编码处理 ）<br>
2、字符读取（编码处理、读取并显示结果 ）<br>
3、短信API（发送短信并获取短信发送结果）<br>
4、疫情数据分析与读取（百度、网易、腾讯、丁香园等疫情数据分析与读取）</p>
<p>主要代码</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;

public class Demo {

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		String code = URLEncoder.encode(&quot;恭喜你，作业已完成！验证码是：你好。如非本人操作，请忽略本短信【开课吧新职课】&quot;, &quot;UTF-8&quot;);
		
		//1.	创建一个网址对象
		URL url = new URL(&quot;http://api.jisuapi.com/sms/send?appkey=5701500bf5e5e1df&amp;mobile=手机号&amp;content=&quot;+code);
		//2.	通过网址对象打开网络连接, 并得到连接对象
		URLConnection conn = url.openConnection();
		//3.	通过连接对象 获取用于读取页面内容的 输入流 ( 字节流 ) 
		InputStream is = conn.getInputStream();
		//4.	将上述的字节流 装饰为 字符流 , 并为字符流添加缓冲,使其可以一次读取一行文本内容
		BufferedReader br = new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));
		//5.	通过上述的br , 读取一行文字内容.并将内容赋值给变量text
		String text = br.readLine();
		System.out.println(text);
	}

}
</code></pre>
<p>Day03<br>
今日任务：疫情地图绘制</p>
<p>任务线索：<br>
1、B\S程序（Tomcat搭建、JSP使用等 ）部署<br>
2、ECharts（引入ECharts和地图绘制等）<br>
3、架构优化（为适应高并发场景进行优化）<br>
4、部署上线（部署至阿里云并添加公众号入口）<br>
主要代码</p>
<pre><code>&lt;%!
String text;
long time = 0; %&gt;
&lt;%
    if(System.currentTimeMillis()-time&gt;60000){
        time = System.currentTimeMillis();
        URL url = new URL(&quot;http://zaixianke.com/yq/info?today&quot;);
        URLConnection conn = url.openConnection();
        InputStream is = conn.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));
        text = br.readLine(); 
    }
%&gt;
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p>疫情地图公众号训练<br>
导图</p>
<p>任务卡</p>
<p>Day01<br>
关机小程序<br>
自动关机</p>
<p>取消自动关机</p>
<pre><code>import java.io.IOException;
import java.util.Scanner;

public class Demo1 {

   public static void main(String[] args) throws IOException{
   	// TODO Auto-generated method stub
   	while(true) {
   		Scanner scanner = new Scanner(System.in);
   		System.out.println(&quot;关机请输入:1, \t取消关机请输入:2, \t退出请输入3!&quot;);
   		System.out.println(&quot;****************************************************&quot;);
   		String select = scanner.next();
   		if(select.equals(&quot;1&quot;)) {
   			System.out.println(&quot;请输入关机秒数，例如3600:&quot;);
   			String time = scanner.next();
   			Runtime.getRuntime().exec(&quot;shutdown -s -t &quot;+time);
   			//System.out.println(&quot;shutdown -s -t &quot;+time);
   			System.out.println(time+&quot;秒后关机&quot;);
   		}else if(select.equals(&quot;2&quot;)) {
   			Runtime.getRuntime().exec(&quot;shutdown -a&quot;);
   			System.out.println(&quot;已取消关机\n&quot;);
   		}else if(select.equals(&quot;3&quot;)){
   			break;
   		}else {
   			System.out.println(&quot;输入错误，请重新输入！&quot;);
   		}
   	}
   }

}
</code></pre>
<p>Day02<br>
今日任务：验证码短信发送<br>
任务线索：<br>
1、URL类（URL、URLConnection、参数传递、编码处理 ）<br>
2、字符读取（编码处理、读取并显示结果 ）<br>
3、短信API（发送短信并获取短信发送结果）<br>
4、疫情数据分析与读取（百度、网易、腾讯、丁香园等疫情数据分析与读取）</p>
<p>主要代码</p>
<pre><code>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;

public class Demo {

	public static void main(String[] args) throws IOException {
		// TODO Auto-generated method stub
		String code = URLEncoder.encode(&quot;恭喜你，作业已完成！验证码是：你好。如非本人操作，请忽略本短信【开课吧新职课】&quot;, &quot;UTF-8&quot;);
		
		//1.	创建一个网址对象
		URL url = new URL(&quot;http://api.jisuapi.com/sms/send?appkey=5701500bf5e5e1df&amp;mobile=手机号&amp;content=&quot;+code);
		//2.	通过网址对象打开网络连接, 并得到连接对象
		URLConnection conn = url.openConnection();
		//3.	通过连接对象 获取用于读取页面内容的 输入流 ( 字节流 ) 
		InputStream is = conn.getInputStream();
		//4.	将上述的字节流 装饰为 字符流 , 并为字符流添加缓冲,使其可以一次读取一行文本内容
		BufferedReader br = new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));
		//5.	通过上述的br , 读取一行文字内容.并将内容赋值给变量text
		String text = br.readLine();
		System.out.println(text);
	}

}
</code></pre>
<p>Day03<br>
今日任务：疫情地图绘制</p>
<p>任务线索：<br>
1、B\S程序（Tomcat搭建、JSP使用等 ）部署<br>
2、ECharts（引入ECharts和地图绘制等）<br>
3、架构优化（为适应高并发场景进行优化）<br>
4、部署上线（部署至阿里云并添加公众号入口）<br>
主要代码</p>
<pre><code>&lt;%!
String text;
long time = 0; %&gt;
&lt;%
    if(System.currentTimeMillis()-time&gt;60000){
        time = System.currentTimeMillis();
        URL url = new URL(&quot;http://zaixianke.com/yq/info?today&quot;);
        URLConnection conn = url.openConnection();
        InputStream is = conn.getInputStream();
        BufferedReader br = new BufferedReader(new InputStreamReader(is,&quot;UTF-8&quot;));
        text = br.readLine(); 
    }
%&gt;
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[445. 两数相加 II]]></title>
        <id>https://oneseek.github.io/post/445-liang-shu-xiang-jia-ii/</id>
        <link href="https://oneseek.github.io/post/445-liang-shu-xiang-jia-ii/">
        </link>
        <updated>2020-04-14T14:54:13.000Z</updated>
        <content type="html"><![CDATA[<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>
输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<pre><code>/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode t = new ListNode(0);
        Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();
        Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();
        while(l1!=null){
            s1.push(l1.val);
            l1 = l1.next;
        }
        while(l2!=null){
            s2.push(l2.val);
            l2 = l2.next;
        }
        Stack&lt;Integer&gt; ans = new Stack&lt;&gt;();
        int j=0;
        while(!s1.empty()&amp;&amp;!s2.empty()){
            int a = s1.pop()+s2.pop()+j;
            
            j = a/10;
            a = a%10;
        
            ans.push(a);
        }
        if(s1.empty()){
            s1 = s2;
        }
        while(!s1.empty()){
            int a = s1.pop() + j;
            
            j = a/10;
            a = a%10;
            
            ans.push(a);
        }
        if(j&gt;0){
            ans.push(j);
        }
        ListNode tmp = t;
        while(!ans.empty()){
            tmp.next = new ListNode(ans.pop());
            tmp = tmp.next;
        }
        return t.next;
    }
}
</code></pre>
<p>主要用到栈和链表，栈判断是非为空用empty（） 这是之前没有记清楚的地方<br>
栈相关函数 pop() peek() push()</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[1124. 表现良好的最长时间段]]></title>
        <id>https://oneseek.github.io/post/1124-biao-xian-liang-hao-de-zui-chang-shi-jian-duan/</id>
        <link href="https://oneseek.github.io/post/1124-biao-xian-liang-hao-de-zui-chang-shi-jian-duan/">
        </link>
        <updated>2020-04-12T14:53:40.000Z</updated>
        <content type="html"><![CDATA[<p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p>
<p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p>
<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p>
<p>请你返回「表现良好时间段」的最大长度。</p>
<p>示例 1：</p>
<p>输入：hours = [9,9,6,0,6,6,9]<br>
输出：3<br>
解释：最长的表现良好时间段是 [9,9,6]。</p>
<p>提示：</p>
<p>1 &lt;= hours.length &lt;= 10000<br>
0 &lt;= hours[i] &lt;= 16</p>
<p>超时</p>
<pre><code>class Solution {
    public int longestWPI(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        if(judge(hours)){
            return hours.length;
        }
        int r = rightJudge(hours);
        int l = leftJudge(hours);

        return r &gt; l ? r : l;
    }

    public boolean judge(int[] hours) {
        int a = 0, b = 0;
        for (int i : hours) {
            if (i &gt; 8) {
                a++;
            } else {
                b++;
            }
        }
        return a &gt; b ? true : false;
    }

    public int leftJudge(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        if(judge(hours)){
            return hours.length;
        }
        int[] arr1 = new int[hours.length-1];
        System.arraycopy(hours, 1, arr1, 0, hours.length-1);
        int r = rightJudge(arr1);
        int l = leftJudge(arr1);
        
        return r&gt;l?r:l;
    }

    public int rightJudge(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        
        if(judge(hours)){
            return hours.length;
        }
        int[] arr1 = new int[hours.length-1];
        System.arraycopy(hours, 0, arr1, 0, hours.length-1);
        int r = rightJudge(arr1);
        int l = leftJudge(arr1);
    
        return r&gt;l?r:l;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[217. 存在重复元素]]></title>
        <id>https://oneseek.github.io/post/217-cun-zai-chong-fu-yuan-su/</id>
        <link href="https://oneseek.github.io/post/217-cun-zai-chong-fu-yuan-su/">
        </link>
        <updated>2020-04-12T13:34:17.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>
输出: true<br>
示例 2:</p>
<p>输入: [1,2,3,4]<br>
输出: false<br>
示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true</p>
<pre><code>class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();
        
        for(int i=0;i&lt;nums.length;i++){
            if(map.get(nums[i])!=null){
                return true;
            }else{
                map.put(nums[i],1);
            }
        }
        return false;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题 03.02. 栈的最小值]]></title>
        <id>https://oneseek.github.io/post/mian-shi-ti-0302-zhan-de-zui-xiao-zhi/</id>
        <link href="https://oneseek.github.io/post/mian-shi-ti-0302-zhan-de-zui-xiao-zhi/">
        </link>
        <updated>2020-04-11T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<p>示例：</p>
<p>MinStack minStack = new MinStack();<br>
minStack.push(-2);<br>
minStack.push(0);<br>
minStack.push(-3);<br>
minStack.getMin();   --&gt; 返回 -3.<br>
minStack.pop();<br>
minStack.top();      --&gt; 返回 0.<br>
minStack.getMin();   --&gt; 返回 -2.</p>
<p>开始用min操作不符合要求，看了题解改了下</p>
<pre><code>class MinStack {
    Node top;
    /** initialize your data structure here. */
    public MinStack() {
        top = new Node();
    }
    
    public void push(int x) {
        int min=x;
        if(x&gt;top.min){
            min=top.min;
        }
        Node n = new Node(x,min);
        n.next = top;
        top = n;
    }
    
    public void pop() {
        top = top.next;
    }
    
    public int top() {
        return top.value;
    }
    
    public int getMin() {
        // int min = top.value;
        // Node n = top;
        // while(n.next!=null){
        //     n = n.next;
        //     if(n.value&lt;min){
        //         min = n.value;
        //     }
        // }
        return top.min;
    }
}
class Node{
    int value;
    Node next;
    int min;
    Node(){
        this.value=Integer.MAX_VALUE;
        this.min=Integer.MAX_VALUE;
    }
    Node(int x,int min){
        this.value = x;
        this.min = min;
    }
    
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
</code></pre>
]]></content>
    </entry>
</feed>