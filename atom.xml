<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-18T14:23:57.518Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[25. K 个一组翻转链表]]></title>
        <id>https://oneseek.github.io/post/25-k-ge-yi-zu-fan-zhuan-lian-biao/</id>
        <link href="https://oneseek.github.io/post/25-k-ge-yi-zu-fan-zhuan-lian-biao/">
        </link>
        <updated>2020-04-18T13:46:23.000Z</updated>
        <content type="html"><![CDATA[<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>
k 是一个正整数，它的值小于或等于链表的长度。<br>
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>示例：<br>
给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5<br>
当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>
当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>说明：<br>
你的算法只能使用常数的额外空间。<br>
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br>
/**</p>
<ul>
<li>Definition for singly-linked list.</li>
<li>public class ListNode {</li>
<li>
<pre><code>int val;
</code></pre>
</li>
<li>
<pre><code>ListNode next;
</code></pre>
</li>
<li>
<pre><code>ListNode(int x) { val = x; }
</code></pre>
</li>
<li>}<br>
*/</li>
</ul>
<pre><code>class Solution {
   public ListNode reverseKGroup(ListNode head, int k) {
       ListNode tail = head;
       for (int i = 0; i &lt; k; i++) {
           //剩余数量小于k的话，则不需要反转。
           if (tail == null) {
               return head;
           }
           tail = tail.next;
       }
       ListNode newHead = reverseK(head, k);
       head.next = reverseKGroup(tail, k);
       
       return newHead;
   }
   public ListNode reverseK(ListNode head, int k) {
       ListNode prev = null;
       ListNode curr = head;
       ListNode next = null;
       while(curr!=null&amp;&amp;k--&gt;0){
           next = curr.next;
           curr.next = prev;
           prev = curr;
           curr = next;
       }
       return prev;
   }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[242. 有效的字母异位词]]></title>
        <id>https://oneseek.github.io/post/242-you-xiao-de-zi-mu-yi-wei-ci/</id>
        <link href="https://oneseek.github.io/post/242-you-xiao-de-zi-mu-yi-wei-ci/">
        </link>
        <updated>2020-04-18T13:45:40.000Z</updated>
        <content type="html"><![CDATA[<p>简单题<br>
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>
示例 1:<br>
输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;<br>
输出: true<br>
示例 2:<br>
输入: s = &quot;rat&quot;, t = &quot;car&quot;<br>
输出: false<br>
说明:<br>
你可以假设字符串只包含小写字母。<br>
进阶:<br>
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？<br>
来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/valid-anagram<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<pre><code>class Solution {
    public boolean isAnagram(String s, String t) {
        int[] arr1 = new int[26];
        int[] arr2 = new int[26];
        for (char i : s.toCharArray()) {
            arr1[(int)i-97]++;
        }
        for (char i : t.toCharArray()) {
            arr2[(int)i-97]++;
        }
        for(int i=0;i&lt;26;i++){
            if(arr1[i]!=arr2[i]){
                return false;
            }
        }
        return true;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[idea maven 资源文件加载不到classes]]></title>
        <id>https://oneseek.github.io/post/idea-maven-zi-yuan-wen-jian-jia-zai-bu-dao-classes/</id>
        <link href="https://oneseek.github.io/post/idea-maven-zi-yuan-wen-jian-jia-zai-bu-dao-classes/">
        </link>
        <updated>2020-04-17T08:48:13.000Z</updated>
        <content type="html"><![CDATA[<p>没找到原因 有人说试idea的bug<br>
解决方法：1、手动复制<br>
2、删除iml文件中的 <code>org.jetbrains.idea.maven.project.MavenProjectsManager.isMavenModule=&quot;true&quot;</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring AOP]]></title>
        <id>https://oneseek.github.io/post/spring-aop/</id>
        <link href="https://oneseek.github.io/post/spring-aop/">
        </link>
        <updated>2020-04-16T08:08:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="官方文档摘抄">官方文档摘抄</h1>
<p>使用 Java Configuration 启用 @AspectJ 支持<br>
要使用 Java @Configuration启用 @AspectJ 支持，请添加@EnableAspectJAutoProxy annotation，如下面的 example 所示：</p>
<pre><code>@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}
</code></pre>
<p>使用 XML Configuration 启用 @AspectJ 支持<br>
要使用 XML-based configuration 启用 @AspectJ 支持，请使用aop:aspectj-autoproxy元素，如下面的 example 所示：</p>
<pre><code>&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[542. 01 矩阵]]></title>
        <id>https://oneseek.github.io/post/542-01-ju-zhen/</id>
        <link href="https://oneseek.github.io/post/542-01-ju-zhen/">
        </link>
        <updated>2020-04-15T16:11:52.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p>
<p>两个相邻元素间的距离为 1 。</p>
<p>示例 1:<br>
输入:</p>
<p>0 0 0<br>
0 1 0<br>
0 0 0<br>
输出:</p>
<p>0 0 0<br>
0 1 0<br>
0 0 0<br>
示例 2:<br>
输入:</p>
<p>0 0 0<br>
0 1 0<br>
1 1 1<br>
输出:</p>
<p>0 0 0<br>
0 1 0<br>
1 2 1<br>
注意:</p>
<p>给定矩阵的元素个数不超过 10000。<br>
给定矩阵中至少有一个元素是 0。<br>
矩阵中的元素只在四个方向上相邻: 上、下、左、右。</p>
<p>超时了，明天再看看正确答案吧</p>
<pre><code>class Solution {
    public int[][] updateMatrix(int[][] matrix) {
        int [][] matrix01 = new int[matrix.length][matrix[0].length];

        for(int i=0;i&lt;matrix.length;i++){
            for(int j=0;j&lt;matrix[0].length;j++){
                matrix01[i][j]=Integer.MAX_VALUE;
            }
        }
        for(int i=0;i&lt;matrix.length;i++){
            for(int j=0;j&lt;matrix[0].length;j++){
                if(matrix[i][j]==0){
                    matrix01[i][j]=0;
                    min(i, j, matrix01);
                }
            }
        }

        return matrix01;
    }

    public void min(int i,int j,int[][] matri01){
        if(i&gt;0){
            if(matri01[i-1][j]&gt;matri01[i][j]+1){
                matri01[i-1][j] = matri01[i][j]+1;
                min(i-1, j, matri01);
            }
        }
        if(j&gt;0){
            if(matri01[i][j-1]&gt;matri01[i][j]+1){
                matri01[i][j-1] = matri01[i][j]+1;
                min(i, j-1, matri01);
            }
        }
        if(i+1&lt;matri01.length){
            if(matri01[i+1][j]&gt;matri01[i][j]+1){
                matri01[i+1][j] = matri01[i][j]+1;
                min(i+1, j, matri01);
            }
        }
        if(j+1&lt;matri01[0].length){
            if(matri01[i][j+1]&gt;matri01[i][j]+1){
                matri01[i][j+1] = matri01[i][j]+1;
                min(i, j+1, matri01);
            }
        }
    }
}

/* 0 0 0 
   0 1 0
   1 1 1*/
</code></pre>
]]></content>
    </entry>
</feed>