<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-27T01:57:02.805Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[Java关键字]]></title>
        <id>https://oneseek.github.io/post/java-guan-jian-zi/</id>
        <link href="https://oneseek.github.io/post/java-guan-jian-zi/">
        </link>
        <updated>2020-03-26T13:07:23.000Z</updated>
        <content type="html"><![CDATA[<p>关键字	含义<br>
abstract	表明类或者成员方法具有抽象属性<br>
assert	断言，用来进行程序调试<br>
boolean	基本数据类型之一，布尔类型<br>
break	提前跳出一个块<br>
byte	基本数据类型之一，字节类型<br>
case	用在switch语句之中，表示其中的一个分支<br>
catch	用在异常处理中，用来捕捉异常<br>
char	基本数据类型之一，字符类型<br>
class	声明一个类<br>
const	保留关键字，没有具体含义<br>
continue	回到一个块的开始处<br>
default	默认，例如，用在switch语句中，表明一个默认的分支<br>
do	用在do-while循环结构中<br>
double	基本数据类型之一，双精度浮点数类型<br>
else	用在条件语句中，表明当条件不成立时的分支<br>
enum	枚举<br>
extends	表明一个类型是另一个类型的子类型，这里常见的类型有类和接口<br>
final	用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量<br>
finally	用于处理异常情况，用来声明一个基本肯定会被执行到的语句块<br>
float	基本数据类型之一，单精度浮点数类型<br>
for	一种循环结构的引导词<br>
goto	保留关键字，没有具体含义<br>
if	条件语句的引导词<br>
implements	表明一个类实现了给定的接口<br>
import	表明要访问指定的类或包<br>
instanceof	用来测试一个对象是否是指定类型的实例对象<br>
int	基本数据类型之一，整数类型<br>
interface	接口<br>
long	基本数据类型之一，长整数类型<br>
native	用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的<br>
new	用来创建新实例对象<br>
package	包<br>
private	一种访问控制方式：私用模式<br>
protected	一种访问控制方式：保护模式<br>
public	一种访问控制方式：共用模式<br>
return	从成员方法中返回数据<br>
short	基本数据类型之一,短整数类型<br>
static	表明具有静态属性<br>
strictfp	用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 [1] <br>
super	表明当前对象的父类型的引用或者父类型的构造方法<br>
switch	分支语句结构的引导词<br>
synchronized	表明一段代码需要同步执行<br>
this	指向当前实例对象的引用<br>
throw	抛出一个异常<br>
throws	声明在当前定义的成员方法中所有需要抛出的异常<br>
transient	声明不用序列化的成员域<br>
try	尝试一个可能抛出异常的程序块<br>
void	声明当前成员方法没有返回值<br>
volatile	表明两个或者多个变量必须同步地发生变化<br>
while	用在循环结构中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell编写显示ps相关脚本]]></title>
        <id>https://oneseek.github.io/post/shell-bian-xie-xian-shi-ps-xiang-guan-jiao-ben/</id>
        <link href="https://oneseek.github.io/post/shell-bian-xie-xian-shi-ps-xiang-guan-jiao-ben/">
        </link>
        <updated>2020-03-25T14:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>编写脚本checkCpu.sh，在脚本中三个函数：getPid、getCpu、checkCpu<br>
getPid：参数1为当前用户名，参数2为进程名称（返回值为进程Pid）<br>
getCpu:参数1为进程的pid（返回值为进程pid的cpu利用率）<br>
checkCpu：参数1为当前用户名，参数2为进程名称    参数3. . . .(进程名称)，无返回值（在函数中打印各个进程cpu占用率）<br>
执行脚本checkCpu.sh时 ，参数1为进程1名称     参数2. . . .(进程名称列表)</p>
<pre><code>#!/bin/bash
getPid(){
username=$1
processname=$2
ps -u $username | grep $processname|grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; | awk '{print $1}';
}
getCpu(){
pid=$1
ps aux |grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; |grep $pid|awk '{print $3}';
}
checkCpu(){
for processname in $*
do
   echo &quot;var = $processname&quot;
   pid=`getPid $USER $processname`
   echo &quot;pid = $pid&quot;
   ret=`getCpu $USER $pid`
   echo &quot;cat = $ret&quot;
done
}
checkCpu $*
</code></pre>
<p>相关命令</p>
<pre><code>ps -u $username | grep $processname|grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; | awk '{print $1}';
</code></pre>
<p>查询对应进程cpu利用率<br>
第一种</p>
<pre><code>ps aux |grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; |grep $pid|awk '{print $3}';
</code></pre>
<p>第二种</p>
<pre><code>ps -p 6672 -o pcpu
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java.lang 类 ClassLoader]]></title>
        <id>https://oneseek.github.io/post/javalang-lei-classloader/</id>
        <link href="https://oneseek.github.io/post/javalang-lei-classloader/">
        </link>
        <updated>2020-03-23T14:22:42.000Z</updated>
        <content type="html"><![CDATA[<p>文档 ： https://tool.oschina.net/apidocs/apidoc?api=jdk-zh</p>
<p><strong>getResource</strong><br>
public URL getResource(String name)<br>
查找具有给定名称的资源。资源是可以通过类代码以与代码基无关的方式访问的一些数据（图像、声音、文本等）。<br>
资源名称是以 '/' 分隔的标识资源的路径名称。</p>
<p>此方法首先搜索资源的父类加载器；如果父类加载器为 null，则搜索的路径就是虚拟机的内置类加载器的路径。如果搜索失败，则此方法将调用 findResource(String) 来查找资源。</p>
<p><strong>参数：</strong><br>
name - 资源名称<br>
<strong>返回：</strong><br>
读取资源的 URL 对象；如果找不到该资源，或者调用者没有足够的权限获取该资源，则返回 null。<br>
<strong>从以下版本开始：</strong><br>
1.1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[106.Jerry的考验]]></title>
        <id>https://oneseek.github.io/post/106jerry-de-kao-yan/</id>
        <link href="https://oneseek.github.io/post/106jerry-de-kao-yan/">
        </link>
        <updated>2020-03-23T02:13:24.000Z</updated>
        <content type="html"><![CDATA[<p>概述：<br>
有一天Jerry给Tom出了一道题来考验他。Jerry给了Tom一个长度为2<em>n的只包含小写字母的字符串，让Tom将这个字符串任意挑选字符，将其分成两个等长的字符串a和b(对于一个si不能同时被选到a和b中)，然后a要和reverse(b)相同(a和反转后的b相同)，问这样的方案数有多少？Tom有些为难，所以请你来帮帮他吧。<br>
输入一个正整数n，和一个长度为2</em>n的字符串<br>
输出方案数</p>
<p>示例1<br>
输入：<br>
2<br>
&quot;abba&quot;<br>
输出：<br>
4</p>
<h3 id="最开始写的c版-直接暴力">最开始写的C++版 直接暴力</h3>
<pre><code>/*有一天Jerry给Tom出了一道题来考验他。
Jerry给了Tom一个长度为2*n的只包含小写字母的字符串，
让Tom将这个字符串任意挑选字符，
将其分成两个等长的字符串a和b(对于一个si不能同时被选到a和b中)，
然后a要和reverse(b)相同(a和反转后的b相同)，
问这样的方案数有多少？Tom有些为难，所以请你来帮帮他吧。
输入一个正整数n，和一个长度为2*n的字符串
输出方案数
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
    int n = 4;
    string a = &quot;abba&quot;;
    int ans = 0;
    for (int i = 0; i &lt; (1 &lt;&lt; n); i++)  //二进制枚举//枚举每一个状态
    {
        string sa = &quot;&quot;;
        string sb = &quot;&quot;;
        for (int j = 0; j &lt; n; j++)  //枚举该状态下二进制的每一位数值
        {
            cout &lt;&lt; i &lt;&lt;&quot;&amp;&quot;&lt;&lt;&quot;(1&lt;&lt;&quot;&lt;&lt;j&lt;&lt; &quot;) &quot; &lt;&lt; (i &amp; (1 &lt;&lt; j)) &lt;&lt; &quot;\t&quot;;
            if (i &amp; (1 &lt;&lt; j))  //当前状态的第i位 ?是否为1(存在
            {
                sa += a[j];
            }
            else {
                sb += a[j];
            }
        }
        cout &lt;&lt; endl;
        reverse(sb.begin(), sb.end());
        if (sa == sb) {
            ans++;
        }
    }

    cout &lt;&lt; ans;

    return 0;
}
</code></pre>
<h3 id="优化一点的折半法-但是还是超时">优化一点的折半法 但是还是超时</h3>
<pre><code>public static long solution(int n, String s) {
        String S_0 = s.substring(0, n);
        String S_1 = s.substring(n, n * 2);
        int ans = 0;

        ArrayList&lt;ArrayList&lt;String&gt;&gt; SSa = fun(n, S_0); // 返回a的所有可能

        ArrayList&lt;String&gt; Sa1 = SSa.get(1); // 得到a选中的字符串的集合
        ArrayList&lt;String&gt; Sa0 = SSa.get(0); // a没有选中的字符串的集合

        SSa = fun(n, S_1); // 返回b的所有可能
        ArrayList&lt;String&gt; Sb0 = SSa.get(1); // 得到b选中的字符串的集合
        ArrayList&lt;String&gt; Sb1 = SSa.get(0); // b没有选中的字符串的集合

        int len = Sb1.size(); // b可能性数目

        // System.out.println(&quot;len=&quot;+len);

        Map&lt;Integer, ArrayList&lt;String&gt;&gt; mapb1 = new HashMap&lt;Integer, ArrayList&lt;String&gt;&gt;();
        Map&lt;Integer, ArrayList&lt;String&gt;&gt; mapb0 = new HashMap&lt;Integer, ArrayList&lt;String&gt;&gt;();

        for (int i = 0; i &lt; len; i++) { //
            String sb1 = Sb1.get(i);
            String sb0 = Sb0.get(i);

            // System.out.println(sb1);

            int sb1_len = sb1.length();
            int sb0_len = sb0.length();

            ArrayList&lt;String&gt; sb1List = mapb1.get(sb1_len);
            ArrayList&lt;String&gt; sb0List = mapb0.get(sb0_len);

            if (sb1List == null) {
                sb1List = new ArrayList&lt;String&gt;();
            }
            if (sb0List == null) {
                sb0List = new ArrayList&lt;String&gt;();
            }

            sb1List.add(sb1);
            sb0List.add(sb0);

            mapb1.put(sb1_len, sb1List);
            mapb0.put(sb0_len, sb0List);
        }

        // System.out.println(mapb1.size());
        // for( Map.Entry&lt;Integer, ArrayList&lt;String&gt;&gt; map:mapb1.entrySet()){
        // System.out.println(map);
        // }
        // System.out.println(len + &quot; &quot; + Math.pow(2, n) + &quot; &quot; + mapb1.size());

        len = Sa1.size();

        int t = 0;
        Map&lt;String,Integer&gt; table = new HashMap&lt;&gt;();
        for (String sa1 : Sa1) {
            String sa0 = Sa0.get(t);
            t++;
            if(table.get(sa1+sa0)!=null){
                ans+=table.get(sa1+sa0);
                continue;
            }
            int sa1_len = sa1.length();
            // System.out.println(t+&quot;:&quot;+sa1+&quot; &quot;+ sa1_count);
            ArrayList&lt;String&gt; sb1List = new ArrayList&lt;String&gt;();
            ArrayList&lt;String&gt; sb0List = new ArrayList&lt;String&gt;();

            sb1List = mapb1.get(n - sa1_len);
            sb0List = mapb0.get(sa1_len);

            if (sb1List == null) {
                sb1List = new ArrayList&lt;String&gt;();
            }
            if (sb0List == null) {
                sb0List = new ArrayList&lt;String&gt;();
            }

            int ans_a=0;
            for (int j = 0; j &lt; sb1List.size(); j++) {
                String fa = sa1 + sb1List.get(j);
                String fb = new StringBuilder(sa0 + sb0List.get(j)).reverse().toString();

                if (fa.equals(fb)) {
                    ans++;
                    ans_a++;
                }
            }
            table.put(sa1+sa0, ans_a);
        }

        return ans;
    }

    public static ArrayList&lt;ArrayList&lt;String&gt;&gt; fun(int n, String s) {
        ArrayList&lt;ArrayList&lt;String&gt;&gt; aList = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();
        ArrayList&lt;String&gt; S1 = new ArrayList&lt;&gt;();
        ArrayList&lt;String&gt; S0 = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; Math.pow(2, n); i++) { // 二进制枚举//枚举每一个状态
            String sa = &quot;&quot;;
            String sb = &quot;&quot;;
            for (int j = 0; j &lt; n; j++) { // 枚举该状态下二进制的每一位数值
                if ((i &amp; (int) Math.pow(2, j)) != 0) { // 当前状态的第i位 ?是否为1(存在
                    sa += s.charAt(j);
                } else {
                    sb += s.charAt(j);
                }
            }
            S1.add(sa);
            S0.add(sb);
        }
        aList.add(S0);
        aList.add(S1);
        return aList;
    }
    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[centos7安装 wordpress]]></title>
        <id>https://oneseek.github.io/post/centos7-an-zhuang-wordpress/</id>
        <link href="https://oneseek.github.io/post/centos7-an-zhuang-wordpress/">
        </link>
        <updated>2020-03-21T05:34:10.000Z</updated>
        <content type="html"><![CDATA[<p>照着教程做 中间遇到一点小问题</p>
<p>在安装 MySQL时 systemctl start mysql.service出现fail</p>
<p>解决方法：需要安装mariadb-server</p>
]]></content>
    </entry>
</feed>