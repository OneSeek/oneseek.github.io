<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-06T03:11:37.970Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[Java实现多线程的三种方法]]></title>
        <id>https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/</id>
        <link href="https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/">
        </link>
        <updated>2020-04-06T02:53:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一种-继承-thread类">第一种 继承 Thread类</h2>
<pre><code> 继承Thread类，并重写Thread中的run方法
</code></pre>
<pre><code>class MyThread extends Thread{
　　@Override
　　public void run(){
 　　　　System.out.println(&quot;创建多线程方法一&quot;);
　　}
}
</code></pre>
<h2 id="第二种-实现-runable接口">第二种 实现 Runable接口</h2>
<pre><code>      实现Runnable接口，重写run()方法
</code></pre>
<pre><code>class MyThread implements Runnable{
     @Override
     public void run(){
         System.out.println(&quot;创建多线程方法二&quot;);
     }
}
</code></pre>
<h2 id="第三种-实现callable接口">第三种 实现Callable接口</h2>
<pre><code>      实现Callable接口，重写call()方法
      可以提供返回值 可以抛出异常
      创建Callable实现类
      创建线程池 submi Callable实现类t
</code></pre>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见关系数据库和非关系数据库]]></title>
        <id>https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/</id>
        <link href="https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/">
        </link>
        <updated>2020-04-06T02:52:33.000Z</updated>
        <content type="html"><![CDATA[<p>​关系数据库 ：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL</p>
<p>​非关系数据库：NoSql、Cloudant、MongoDb、redis、HBase</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://oneseek.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://oneseek.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2020-04-05T13:43:17.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>
11110<br>
11010<br>
11000<br>
00000</p>
<p>输出: 1<br>
示例 2:</p>
<p>输入:<br>
11000<br>
11000<br>
00100<br>
00011</p>
<p>输出: 3</p>
<pre><code>class Solution {
    public int numIslands(char[][] grid) {
        int nums = 0;
        int h = grid.length;
        int w = grid.length&gt;0?grid[0].length:0;
        for(int i=0;i&lt;h;i++){
            for(int j=0;j&lt;w;j++){
                System.out.print(grid[i][j]+&quot; &quot;);
                if(grid[i][j]=='1'){
                    nums++;
                    dfs(i,j,grid);
                }
            }
            System.out.println();
        }
        return nums;
    }
    
    void dfs(int i,int j,char[][] grid){
        grid[i][j]='0';
        if(j&lt;grid[0].length-1){
            if(grid[i][j+1]=='1'){
                grid[i][j+1]='0';
                dfs(i,j+1,grid);
            }  
        }
        if(i&lt;grid.length-1){
            if(grid[i+1][j]=='1'){
                grid[i+1][j]='0';
                dfs(i+1,j,grid);
            }  
        }
        if(i&gt;0){
            if(grid[i-1][j]=='1'){
                grid[i-1][j]='0';
                dfs(i-1,j,grid);
            }  
        }
        if(j&gt;0){
            if(grid[i][j-1]=='1'){
                grid[i][j-1]='0';
                dfs(i,j-1,grid);
            }  
        }
        
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode：42. 接雨水]]></title>
        <id>https://oneseek.github.io/post/leetcode42-jie-yu-shui/</id>
        <link href="https://oneseek.github.io/post/leetcode42-jie-yu-shui/">
        </link>
        <updated>2020-04-04T14:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://oneseek.github.io/post-images/1586010946546.png" alt="" loading="lazy"><br>
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>
示例:<br>
输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出: 6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[世事变迁，历史沿革]]></title>
        <id>https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/</id>
        <link href="https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/">
        </link>
        <updated>2020-04-04T13:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>世事变迁，历史沿革</p>
<p>等有时间了，一定要重新整个舒服的博客 (╯▔皿▔)╯</p>
]]></content>
    </entry>
</feed>