<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-29T07:22:11.043Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[Linux jar包 后台运行]]></title>
        <id>https://oneseek.github.io/post/linux-jar-bao-hou-tai-yun-xing/</id>
        <link href="https://oneseek.github.io/post/linux-jar-bao-hou-tai-yun-xing/">
        </link>
        <updated>2020-03-29T07:20:28.000Z</updated>
        <content type="html"><![CDATA[<pre><code>持续后台运行命令：nohup java-jar xxx项目.jar &gt;xxxx项目.log 2&gt;&amp;1 &amp;

nohup：表示当前用户和系统的会话下的进程忽略响应HUP消息

&amp;是把该命令以后台的job的形式运行

0 表示stdin标准输入；

1 表示stdout标准输出；

2 表示stderr标准错误

&gt; 重定向符号

&gt;xxxx项目.log 2&gt;&amp;1  把标准错误重定向到标准输出 xxx项目.log文件中
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日刷题]]></title>
        <id>https://oneseek.github.io/post/mei-ri-shua-ti/</id>
        <link href="https://oneseek.github.io/post/mei-ri-shua-ti/">
        </link>
        <updated>2020-03-29T03:35:30.000Z</updated>
        <content type="html"><![CDATA[<p>在按层次遍历二叉树的算法中，需要借助的数据结构是（  ）。队列<br>
在类方法中调用本类的类方法时可直接调用<br>
设与某资源相关联的信号量初值为3，当前为1，若M表示该资源的可用个数，N表示等待该资源的进程数，则M，N分别是()      1，0<br>
虚拟局域网是一种新型局域网。<br>
CISCO 4500 能提供E1接口的路由器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练 素因子去重]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-su-yin-zi-qu-chong/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-su-yin-zi-qu-chong/">
        </link>
        <updated>2020-03-27T13:39:58.000Z</updated>
        <content type="html"><![CDATA[<p>试题 算法训练 素因子去重</p>
<p>资源限制<br>
时间限制：1.0s   内存限制：256.0MB<br>
问题描述<br>
　　给定一个正整数n，求一个正整数p，满足p仅包含n的所有素因子，且每个素因子的次数不大于1<br>
输入格式<br>
　　一个整数，表示n<br>
输出格式<br>
　　输出一行，包含一个整数p。<br>
样例输入<br>
1000<br>
样例输出<br>
10<br>
数据规模和约定<br>
　　n&lt;=10^12<br>
　　样例解释：n=1000=2^3<em>5</em>3，p=2*5=10</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
typedef long long ll;

using namespace std;
int main() {
    ll n;
    cin &gt;&gt; n;
    
    map&lt;ll, int&gt; num;
    while (n % 2 == 0) {
        num[2]=1;
        n /= 2;
    }
    for (ll i = 3; i &lt;= sqrt(n * 1.0); i += 2) {
        while (n % i == 0) {
            num[i]=1;
            n /= i;
        }
    }
    if (n &gt; 2) {
        num[n]=1;
    }

    ll ans=1;
    for (map&lt;ll, int&gt;::iterator it = num.begin(); it != num.end(); ++it){
        
		ans *= it-&gt;first;
         
    }

    cout&lt;&lt;ans;
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java关键字]]></title>
        <id>https://oneseek.github.io/post/java-guan-jian-zi/</id>
        <link href="https://oneseek.github.io/post/java-guan-jian-zi/">
        </link>
        <updated>2020-03-26T13:07:23.000Z</updated>
        <content type="html"><![CDATA[<p>关键字	含义<br>
abstract	表明类或者成员方法具有抽象属性<br>
assert	断言，用来进行程序调试<br>
boolean	基本数据类型之一，布尔类型<br>
break	提前跳出一个块<br>
byte	基本数据类型之一，字节类型<br>
case	用在switch语句之中，表示其中的一个分支<br>
catch	用在异常处理中，用来捕捉异常<br>
char	基本数据类型之一，字符类型<br>
class	声明一个类<br>
const	保留关键字，没有具体含义<br>
continue	回到一个块的开始处<br>
default	默认，例如，用在switch语句中，表明一个默认的分支<br>
do	用在do-while循环结构中<br>
double	基本数据类型之一，双精度浮点数类型<br>
else	用在条件语句中，表明当条件不成立时的分支<br>
enum	枚举<br>
extends	表明一个类型是另一个类型的子类型，这里常见的类型有类和接口<br>
final	用来说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变，用来定义常量<br>
finally	用于处理异常情况，用来声明一个基本肯定会被执行到的语句块<br>
float	基本数据类型之一，单精度浮点数类型<br>
for	一种循环结构的引导词<br>
goto	保留关键字，没有具体含义<br>
if	条件语句的引导词<br>
implements	表明一个类实现了给定的接口<br>
import	表明要访问指定的类或包<br>
instanceof	用来测试一个对象是否是指定类型的实例对象<br>
int	基本数据类型之一，整数类型<br>
interface	接口<br>
long	基本数据类型之一，长整数类型<br>
native	用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的<br>
new	用来创建新实例对象<br>
package	包<br>
private	一种访问控制方式：私用模式<br>
protected	一种访问控制方式：保护模式<br>
public	一种访问控制方式：共用模式<br>
return	从成员方法中返回数据<br>
short	基本数据类型之一,短整数类型<br>
static	表明具有静态属性<br>
strictfp	用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 [1] <br>
super	表明当前对象的父类型的引用或者父类型的构造方法<br>
switch	分支语句结构的引导词<br>
synchronized	表明一段代码需要同步执行<br>
this	指向当前实例对象的引用<br>
throw	抛出一个异常<br>
throws	声明在当前定义的成员方法中所有需要抛出的异常<br>
transient	声明不用序列化的成员域<br>
try	尝试一个可能抛出异常的程序块<br>
void	声明当前成员方法没有返回值<br>
volatile	表明两个或者多个变量必须同步地发生变化<br>
while	用在循环结构中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell编写显示ps相关脚本]]></title>
        <id>https://oneseek.github.io/post/shell-bian-xie-xian-shi-ps-xiang-guan-jiao-ben/</id>
        <link href="https://oneseek.github.io/post/shell-bian-xie-xian-shi-ps-xiang-guan-jiao-ben/">
        </link>
        <updated>2020-03-25T14:26:55.000Z</updated>
        <content type="html"><![CDATA[<p>编写脚本checkCpu.sh，在脚本中三个函数：getPid、getCpu、checkCpu<br>
getPid：参数1为当前用户名，参数2为进程名称（返回值为进程Pid）<br>
getCpu:参数1为进程的pid（返回值为进程pid的cpu利用率）<br>
checkCpu：参数1为当前用户名，参数2为进程名称    参数3. . . .(进程名称)，无返回值（在函数中打印各个进程cpu占用率）<br>
执行脚本checkCpu.sh时 ，参数1为进程1名称     参数2. . . .(进程名称列表)</p>
<pre><code>#!/bin/bash
getPid(){
username=$1
processname=$2
ps -u $username | grep $processname|grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; | awk '{print $1}';
}
getCpu(){
pid=$1
ps aux |grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; |grep $pid|awk '{print $3}';
}
checkCpu(){
for processname in $*
do
   echo &quot;var = $processname&quot;
   pid=`getPid $USER $processname`
   echo &quot;pid = $pid&quot;
   ret=`getCpu $USER $pid`
   echo &quot;cat = $ret&quot;
done
}
checkCpu $*
</code></pre>
<p>相关命令</p>
<pre><code>ps -u $username | grep $processname|grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; | awk '{print $1}';
</code></pre>
<p>查询对应进程cpu利用率<br>
第一种</p>
<pre><code>ps aux |grep -v &quot;checkCpu&quot;|grep -v &quot;grep&quot; |grep $pid|awk '{print $3}';
</code></pre>
<p>第二种</p>
<pre><code>ps -p 6672 -o pcpu
</code></pre>
]]></content>
    </entry>
</feed>