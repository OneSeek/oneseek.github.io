<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-05T13:44:18.376Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://oneseek.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://oneseek.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2020-04-05T13:43:17.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>
11110<br>
11010<br>
11000<br>
00000</p>
<p>输出: 1<br>
示例 2:</p>
<p>输入:<br>
11000<br>
11000<br>
00100<br>
00011</p>
<p>输出: 3</p>
<pre><code>class Solution {
    public int numIslands(char[][] grid) {
        int nums = 0;
        int h = grid.length;
        int w = grid.length&gt;0?grid[0].length:0;
        for(int i=0;i&lt;h;i++){
            for(int j=0;j&lt;w;j++){
                System.out.print(grid[i][j]+&quot; &quot;);
                if(grid[i][j]=='1'){
                    nums++;
                    dfs(i,j,grid);
                }
            }
            System.out.println();
        }
        return nums;
    }
    
    void dfs(int i,int j,char[][] grid){
        grid[i][j]='0';
        if(j&lt;grid[0].length-1){
            if(grid[i][j+1]=='1'){
                grid[i][j+1]='0';
                dfs(i,j+1,grid);
            }  
        }
        if(i&lt;grid.length-1){
            if(grid[i+1][j]=='1'){
                grid[i+1][j]='0';
                dfs(i+1,j,grid);
            }  
        }
        if(i&gt;0){
            if(grid[i-1][j]=='1'){
                grid[i-1][j]='0';
                dfs(i-1,j,grid);
            }  
        }
        if(j&gt;0){
            if(grid[i][j-1]=='1'){
                grid[i][j-1]='0';
                dfs(i,j-1,grid);
            }  
        }
        
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode：42. 接雨水]]></title>
        <id>https://oneseek.github.io/post/leetcode42-jie-yu-shui/</id>
        <link href="https://oneseek.github.io/post/leetcode42-jie-yu-shui/">
        </link>
        <updated>2020-04-04T14:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://oneseek.github.io/post-images/1586010946546.png" alt="" loading="lazy"><br>
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>
示例:<br>
输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出: 6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[世事变迁，历史沿革]]></title>
        <id>https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/</id>
        <link href="https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/">
        </link>
        <updated>2020-04-04T13:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>世事变迁，历史沿革</p>
<p>等有时间了，一定要重新整个舒服的博客 (╯▔皿▔)╯</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[synchronized]]></title>
        <id>https://oneseek.github.io/post/synchronized/</id>
        <link href="https://oneseek.github.io/post/synchronized/">
        </link>
        <updated>2020-04-04T07:27:56.000Z</updated>
        <content type="html"><![CDATA[<p>synchronized<br>
保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring implement HandlerInterceptor 接口 实现权限管理]]></title>
        <id>https://oneseek.github.io/post/spring-implement-handlerinterceptor-jie-kou-shi-xian-quan-xian-guan-li/</id>
        <link href="https://oneseek.github.io/post/spring-implement-handlerinterceptor-jie-kou-shi-xian-quan-xian-guan-li/">
        </link>
        <updated>2020-03-31T08:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>先写一个类实现 HandlerInterceptor<br>
重写 preHandle函数 保存 request 的 user session对象 然后 sendRedirect重定向到登陆界面</p>
<h3 id="role判断">role判断</h3>
<p>定义一个type 从前台传送到后台 判断type后 验证用户密码</p>
]]></content>
    </entry>
</feed>