<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-29T16:27:38.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[NIO实现简单服务器]]></title>
        <id>https://oneseek.github.io/post/nio-shi-xian-jian-dan-fu-wu-qi/</id>
        <link href="https://oneseek.github.io/post/nio-shi-xian-jian-dan-fu-wu-qi/">
        </link>
        <updated>2020-03-29T16:27:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
/**
 * @Author: Chuang
 * @Date: 2020/3/29 22:34
 */


public class NioServer {

    private int port;

    private Selector selector;

    public NioServer(int port) {
        this.port = port;
    }

    public void startListen() throws IOException {
        selector = Selector.open();

        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        serverChannel.bind(new InetSocketAddress(port));

        while (true) {
            //不能使用select方法，该方法会阻塞，如果在阻塞过程中channel状态就绪，会因此处阻塞而无法执行。
            //所以，如果调用阻塞方法，下面对channel状态的处理得另起一个常驻线程
            int result = selector.selectNow();
            if (result == 0) {
                continue;
            }

            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
            while (it.hasNext()) {
                SelectionKey key = it.next();
                if (key.isAcceptable()) {
                    accept(key);
                } else if (key.isReadable()) {
                    read(key);
                } else if (key.isWritable()) {
                    write(key);
                } else {
                    System.out.println(&quot;Unknow selector type&quot;);
                }

                //一定要调用remove方法将已经处理过的SelectionKey清除掉，否则会造成后面的请求无法接受
                it.remove();
            }
        }
    }

    private void accept(SelectionKey key) throws IOException {
        System.out.println(&quot;Receive connection&quot;);
        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
        SocketChannel channel = serverSocketChannel.accept();

        if (channel != null) {
            channel.configureBlocking(false);
            channel.register(selector, SelectionKey.OP_READ);
        }
        System.out.println(&quot;Connection end&quot;);
    }

    private void read(SelectionKey key) throws IOException {
        System.out.println(&quot;Start read&quot;);
        SocketChannel channel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(64);
        boolean hasContent = false;

        //这里的判断条件不能是不等于-1，因为channel一直都在，只是在数据被读完后里面为空，返回的长度是0.用-1判断会无限循环无法退出
        while (channel.read(buffer) &gt; 0) {
            buffer.flip(); //切换为读模式
            CharBuffer cb = Charset.forName(&quot;UTF-8&quot;).decode(buffer);
            System.out.print(cb.toString());
            buffer.clear();
            hasContent = true;
        }

        if (hasContent) {
            //设置interestOps，用于写响应
            key.interestOps(SelectionKey.OP_WRITE);
        } else {
            channel.close();
        }
        System.out.println(&quot;Read end&quot;);
    }

    private void write(SelectionKey key) throws IOException {
        System.out.println(&quot;Start write&quot;);
        SocketChannel channel = (SocketChannel) key.channel();

        String resText = getResponseText();
        ByteBuffer buffer = ByteBuffer.wrap(resText.getBytes());

        //此处不可使用channel.write(buffer) != -1来判断，因为在两端都不关闭的情况下，会一直返回0，导致该循环无法退出
        while (buffer.hasRemaining()) {
            channel.write(buffer);
        }
        channel.close();
        System.out.println(&quot;End write&quot;);
    }

    private String getResponseText() {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;HTTP/1.1 200 OK\n&quot;);
        sb.append(&quot;Content-Type: text/html; charset=UTF-8\n&quot;);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;&lt;html&gt;&quot;);
        sb.append(&quot;  &lt;head&gt;&quot;);
        sb.append(&quot;    &lt;title&gt;&quot;);
        sb.append(&quot;      NIO Http Server&quot;);
        sb.append(&quot;    &lt;/title&gt;&quot;);
        sb.append(&quot;  &lt;/head&gt;&quot;);
        sb.append(&quot;  &lt;body&gt;&quot;);
        sb.append(&quot;    &lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);
        sb.append(&quot;  &lt;/body&gt;&quot;);
        sb.append(&quot;&lt;/html&gt;&quot;);

        return sb.toString();
    }

    public static void main(String[] args) {
        NioServer server = new NioServer(8888);

        try {

            server.startListen();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[AIO实现简单http服务器]]></title>
        <id>https://oneseek.github.io/post/aio-shi-xian-jian-dan-http-fu-wu-qi/</id>
        <link href="https://oneseek.github.io/post/aio-shi-xian-jian-dan-http-fu-wu-qi/">
        </link>
        <updated>2020-03-29T16:25:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousChannelGroup;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

/**
 * 一个简单的web 服务器&lt;br/&gt;
 * 通过浏览器输入localhost:8080/访问
 * 
 * @author Joeson
 * @since 2014/05
 * 
 */
public class AioServer implements Runnable
{
 
	private AsynchronousChannelGroup asyncChannelGroup;
	private AsynchronousServerSocketChannel server;
 
	public AioServer(int port) throws Exception
	{
		// 创建线程池
		ExecutorService executor = Executors.newFixedThreadPool(20);
		// 异步通道管理器
		asyncChannelGroup = AsynchronousChannelGroup.withThreadPool(executor);
		// 创建 用在服务端的异步Socket.以下简称服务器socket。
		// 异步通道管理器，会把服务端所用到的相关参数
		server = AsynchronousServerSocketChannel.open(asyncChannelGroup).bind(
				new InetSocketAddress(port));
	}
 
	public void run()
	{
		try
		{
 
			// 为服务端socket指定接收操作对象.accept原型是：
			// accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel,
			// ? super A&gt; handler)
			// 也就是这里的CompletionHandler的A型参数是实际调用accept方法的第一个参数
			// 即是listener。另一个参数V，就是原型中的客户端socket
			server.accept(
					server,
					new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;()
					{
						String str = &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;this is a socketserver test&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
						String CRLF = &quot;\r\n&quot;;
						// 响应头的参数
						String serverLine = &quot;Server:a simple java WebServer&quot;;
						String statusLine = &quot;HTTP/1.1 200 OK&quot; + CRLF;
						String contentTypeLine = &quot;Content-type:text/html&quot;
								+ CRLF;
						String contentLengthLine = &quot;Content-Length:&quot; + str.length()
								+ CRLF;
 
 
						@Override
						public void completed(AsynchronousSocketChannel result,
								AsynchronousServerSocketChannel attachment)
						{
							// TODO Auto-generated method stub
							// writeChannel(result, statusLine);
							// writeChannel(result, serverLine);
							// writeChannel(result, contentTypeLine);
							// writeChannel(result, contentLengthLine);
							// writeChannel(result, CRLF);
 
							writeChannel(result, statusLine + serverLine
									+ contentTypeLine + contentLengthLine
									+ CRLF + str);
 
							// writeChannel(result, str);
 
							try
							{
								result.shutdownOutput();
								result.shutdownInput();
							} catch (IOException e)
							{
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
 
							try
							{
								result.close();
							} catch (IOException e)
							{
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
 
							attachment.accept(attachment, this);
 
						}
 
						@Override
						public void failed(Throwable exc,
								AsynchronousServerSocketChannel attachment)
						{
							// TODO Auto-generated method stub
 
						}
 
						public void writeChannel(
								AsynchronousSocketChannel channel, String s)
						{
							Future&lt;Integer&gt; future = channel.write(ByteBuffer
									.wrap(s.getBytes()));
 
							try
							{
								future.get();
							} catch (InterruptedException e)
							{
								// TODO Auto-generated catch block
								e.printStackTrace();
							} catch (ExecutionException e)
							{
								// TODO Auto-generated catch block
								e.printStackTrace();
							}
						}
 
					});
			Thread.sleep(400000);
		} catch (Exception e)
		{
			e.printStackTrace();
		} finally
		{
			System.out.println(&quot;finished server&quot;);
		}
	}
 
	public static void main(String... args) throws Exception
	{
		AioServer server = new AioServer(8888);
		new Thread(server).start();
	}
 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux jar包 后台运行]]></title>
        <id>https://oneseek.github.io/post/linux-jar-bao-hou-tai-yun-xing/</id>
        <link href="https://oneseek.github.io/post/linux-jar-bao-hou-tai-yun-xing/">
        </link>
        <updated>2020-03-29T07:20:28.000Z</updated>
        <content type="html"><![CDATA[<pre><code>持续后台运行命令：nohup java-jar xxx项目.jar &gt;xxxx项目.log 2&gt;&amp;1 &amp;

nohup：表示当前用户和系统的会话下的进程忽略响应HUP消息

&amp;是把该命令以后台的job的形式运行

0 表示stdin标准输入；

1 表示stdout标准输出；

2 表示stderr标准错误

&gt; 重定向符号

&gt;xxxx项目.log 2&gt;&amp;1  把标准错误重定向到标准输出 xxx项目.log文件中
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[每日刷题]]></title>
        <id>https://oneseek.github.io/post/mei-ri-shua-ti/</id>
        <link href="https://oneseek.github.io/post/mei-ri-shua-ti/">
        </link>
        <updated>2020-03-29T03:35:30.000Z</updated>
        <content type="html"><![CDATA[<p>在按层次遍历二叉树的算法中，需要借助的数据结构是（  ）。队列<br>
在类方法中调用本类的类方法时可直接调用<br>
设与某资源相关联的信号量初值为3，当前为1，若M表示该资源的可用个数，N表示等待该资源的进程数，则M，N分别是()      1，0<br>
虚拟局域网是一种新型局域网。<br>
CISCO 4500 能提供E1接口的路由器</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练 素因子去重]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-su-yin-zi-qu-chong/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-su-yin-zi-qu-chong/">
        </link>
        <updated>2020-03-27T13:39:58.000Z</updated>
        <content type="html"><![CDATA[<p>试题 算法训练 素因子去重</p>
<p>资源限制<br>
时间限制：1.0s   内存限制：256.0MB<br>
问题描述<br>
　　给定一个正整数n，求一个正整数p，满足p仅包含n的所有素因子，且每个素因子的次数不大于1<br>
输入格式<br>
　　一个整数，表示n<br>
输出格式<br>
　　输出一行，包含一个整数p。<br>
样例输入<br>
1000<br>
样例输出<br>
10<br>
数据规模和约定<br>
　　n&lt;=10^12<br>
　　样例解释：n=1000=2^3<em>5</em>3，p=2*5=10</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
typedef long long ll;

using namespace std;
int main() {
    ll n;
    cin &gt;&gt; n;
    
    map&lt;ll, int&gt; num;
    while (n % 2 == 0) {
        num[2]=1;
        n /= 2;
    }
    for (ll i = 3; i &lt;= sqrt(n * 1.0); i += 2) {
        while (n % i == 0) {
            num[i]=1;
            n /= i;
        }
    }
    if (n &gt; 2) {
        num[n]=1;
    }

    ll ans=1;
    for (map&lt;ll, int&gt;::iterator it = num.begin(); it != num.end(); ++it){
        
		ans *= it-&gt;first;
         
    }

    cout&lt;&lt;ans;
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>