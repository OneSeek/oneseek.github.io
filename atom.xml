<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-05T02:44:30.620Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[leetcode：42. 接雨水]]></title>
        <id>https://oneseek.github.io/post/leetcode42-jie-yu-shui/</id>
        <link href="https://oneseek.github.io/post/leetcode42-jie-yu-shui/">
        </link>
        <updated>2020-04-04T14:33:07.000Z</updated>
        <content type="html"><![CDATA[<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br>
<img src="https://oneseek.github.io/post-images/1586010946546.png" alt="" loading="lazy"><br>
上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。<br>
示例:<br>
输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>
输出: 6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[世事变迁，历史沿革]]></title>
        <id>https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/</id>
        <link href="https://oneseek.github.io/post/shi-shi-bian-qian-li-shi-yan-ge/">
        </link>
        <updated>2020-04-04T13:32:07.000Z</updated>
        <content type="html"><![CDATA[<p>世事变迁，历史沿革</p>
<p>等有时间了，一定要重新整个舒服的博客 (╯▔皿▔)╯</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[synchronized]]></title>
        <id>https://oneseek.github.io/post/synchronized/</id>
        <link href="https://oneseek.github.io/post/synchronized/">
        </link>
        <updated>2020-04-04T07:27:56.000Z</updated>
        <content type="html"><![CDATA[<p>synchronized<br>
保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring implement HandlerInterceptor 接口 实现权限管理]]></title>
        <id>https://oneseek.github.io/post/spring-implement-handlerinterceptor-jie-kou-shi-xian-quan-xian-guan-li/</id>
        <link href="https://oneseek.github.io/post/spring-implement-handlerinterceptor-jie-kou-shi-xian-quan-xian-guan-li/">
        </link>
        <updated>2020-03-31T08:59:17.000Z</updated>
        <content type="html"><![CDATA[<p>先写一个类实现 HandlerInterceptor<br>
重写 preHandle函数 保存 request 的 user session对象 然后 sendRedirect重定向到登陆界面</p>
<h3 id="role判断">role判断</h3>
<p>定义一个type 从前台传送到后台 判断type后 验证用户密码</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[NIO实现简单服务器]]></title>
        <id>https://oneseek.github.io/post/nio-shi-xian-jian-dan-fu-wu-qi/</id>
        <link href="https://oneseek.github.io/post/nio-shi-xian-jian-dan-fu-wu-qi/">
        </link>
        <updated>2020-03-29T16:27:03.000Z</updated>
        <content type="html"><![CDATA[<pre><code>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.Iterator;
/**
 * @Author: Chuang
 * @Date: 2020/3/29 22:34
 */


public class NioServer {

    private int port;

    private Selector selector;

    public NioServer(int port) {
        this.port = port;
    }

    public void startListen() throws IOException {
        selector = Selector.open();

        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.configureBlocking(false);
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        serverChannel.bind(new InetSocketAddress(port));

        while (true) {
            //不能使用select方法，该方法会阻塞，如果在阻塞过程中channel状态就绪，会因此处阻塞而无法执行。
            //所以，如果调用阻塞方法，下面对channel状态的处理得另起一个常驻线程
            int result = selector.selectNow();
            if (result == 0) {
                continue;
            }

            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();
            while (it.hasNext()) {
                SelectionKey key = it.next();
                if (key.isAcceptable()) {
                    accept(key);
                } else if (key.isReadable()) {
                    read(key);
                } else if (key.isWritable()) {
                    write(key);
                } else {
                    System.out.println(&quot;Unknow selector type&quot;);
                }

                //一定要调用remove方法将已经处理过的SelectionKey清除掉，否则会造成后面的请求无法接受
                it.remove();
            }
        }
    }

    private void accept(SelectionKey key) throws IOException {
        System.out.println(&quot;Receive connection&quot;);
        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
        SocketChannel channel = serverSocketChannel.accept();

        if (channel != null) {
            channel.configureBlocking(false);
            channel.register(selector, SelectionKey.OP_READ);
        }
        System.out.println(&quot;Connection end&quot;);
    }

    private void read(SelectionKey key) throws IOException {
        System.out.println(&quot;Start read&quot;);
        SocketChannel channel = (SocketChannel) key.channel();
        ByteBuffer buffer = ByteBuffer.allocate(64);
        boolean hasContent = false;

        //这里的判断条件不能是不等于-1，因为channel一直都在，只是在数据被读完后里面为空，返回的长度是0.用-1判断会无限循环无法退出
        while (channel.read(buffer) &gt; 0) {
            buffer.flip(); //切换为读模式
            CharBuffer cb = Charset.forName(&quot;UTF-8&quot;).decode(buffer);
            System.out.print(cb.toString());
            buffer.clear();
            hasContent = true;
        }

        if (hasContent) {
            //设置interestOps，用于写响应
            key.interestOps(SelectionKey.OP_WRITE);
        } else {
            channel.close();
        }
        System.out.println(&quot;Read end&quot;);
    }

    private void write(SelectionKey key) throws IOException {
        System.out.println(&quot;Start write&quot;);
        SocketChannel channel = (SocketChannel) key.channel();

        String resText = getResponseText();
        ByteBuffer buffer = ByteBuffer.wrap(resText.getBytes());

        //此处不可使用channel.write(buffer) != -1来判断，因为在两端都不关闭的情况下，会一直返回0，导致该循环无法退出
        while (buffer.hasRemaining()) {
            channel.write(buffer);
        }
        channel.close();
        System.out.println(&quot;End write&quot;);
    }

    private String getResponseText() {
        StringBuffer sb = new StringBuffer();
        sb.append(&quot;HTTP/1.1 200 OK\n&quot;);
        sb.append(&quot;Content-Type: text/html; charset=UTF-8\n&quot;);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;&lt;html&gt;&quot;);
        sb.append(&quot;  &lt;head&gt;&quot;);
        sb.append(&quot;    &lt;title&gt;&quot;);
        sb.append(&quot;      NIO Http Server&quot;);
        sb.append(&quot;    &lt;/title&gt;&quot;);
        sb.append(&quot;  &lt;/head&gt;&quot;);
        sb.append(&quot;  &lt;body&gt;&quot;);
        sb.append(&quot;    &lt;h1&gt;Hello World!&lt;/h1&gt;&quot;);
        sb.append(&quot;  &lt;/body&gt;&quot;);
        sb.append(&quot;&lt;/html&gt;&quot;);

        return sb.toString();
    }

    public static void main(String[] args) {
        NioServer server = new NioServer(8888);

        try {

            server.startListen();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre>
]]></content>
    </entry>
</feed>