<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-12T14:58:18.807Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[1124. 表现良好的最长时间段]]></title>
        <id>https://oneseek.github.io/post/1124-biao-xian-liang-hao-de-zui-chang-shi-jian-duan/</id>
        <link href="https://oneseek.github.io/post/1124-biao-xian-liang-hao-de-zui-chang-shi-jian-duan/">
        </link>
        <updated>2020-04-12T14:53:40.000Z</updated>
        <content type="html"><![CDATA[<p>给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。</p>
<p>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。</p>
<p>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。</p>
<p>请你返回「表现良好时间段」的最大长度。</p>
<p>示例 1：</p>
<p>输入：hours = [9,9,6,0,6,6,9]<br>
输出：3<br>
解释：最长的表现良好时间段是 [9,9,6]。</p>
<p>提示：</p>
<p>1 &lt;= hours.length &lt;= 10000<br>
0 &lt;= hours[i] &lt;= 16</p>
<p>超时</p>
<pre><code>class Solution {
    public int longestWPI(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        if(judge(hours)){
            return hours.length;
        }
        int r = rightJudge(hours);
        int l = leftJudge(hours);

        return r &gt; l ? r : l;
    }

    public boolean judge(int[] hours) {
        int a = 0, b = 0;
        for (int i : hours) {
            if (i &gt; 8) {
                a++;
            } else {
                b++;
            }
        }
        return a &gt; b ? true : false;
    }

    public int leftJudge(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        if(judge(hours)){
            return hours.length;
        }
        int[] arr1 = new int[hours.length-1];
        System.arraycopy(hours, 1, arr1, 0, hours.length-1);
        int r = rightJudge(arr1);
        int l = leftJudge(arr1);
        
        return r&gt;l?r:l;
    }

    public int rightJudge(int[] hours) {
        if(hours.length==0){
            return 0;
        }
        
        if(judge(hours)){
            return hours.length;
        }
        int[] arr1 = new int[hours.length-1];
        System.arraycopy(hours, 0, arr1, 0, hours.length-1);
        int r = rightJudge(arr1);
        int l = leftJudge(arr1);
    
        return r&gt;l?r:l;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[217. 存在重复元素]]></title>
        <id>https://oneseek.github.io/post/217-cun-zai-chong-fu-yuan-su/</id>
        <link href="https://oneseek.github.io/post/217-cun-zai-chong-fu-yuan-su/">
        </link>
        <updated>2020-04-12T13:34:17.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>
输出: true<br>
示例 2:</p>
<p>输入: [1,2,3,4]<br>
输出: false<br>
示例 3:</p>
<p>输入: [1,1,1,3,3,4,3,2,4,2]<br>
输出: true</p>
<pre><code>class Solution {
    public boolean containsDuplicate(int[] nums) {
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();
        
        for(int i=0;i&lt;nums.length;i++){
            if(map.get(nums[i])!=null){
                return true;
            }else{
                map.put(nums[i],1);
            }
        }
        return false;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题 03.02. 栈的最小值]]></title>
        <id>https://oneseek.github.io/post/mian-shi-ti-0302-zhan-de-zui-xiao-zhi/</id>
        <link href="https://oneseek.github.io/post/mian-shi-ti-0302-zhan-de-zui-xiao-zhi/">
        </link>
        <updated>2020-04-11T15:20:11.000Z</updated>
        <content type="html"><![CDATA[<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<p>示例：</p>
<p>MinStack minStack = new MinStack();<br>
minStack.push(-2);<br>
minStack.push(0);<br>
minStack.push(-3);<br>
minStack.getMin();   --&gt; 返回 -3.<br>
minStack.pop();<br>
minStack.top();      --&gt; 返回 0.<br>
minStack.getMin();   --&gt; 返回 -2.</p>
<p>开始用min操作不符合要求，看了题解改了下</p>
<pre><code>class MinStack {
    Node top;
    /** initialize your data structure here. */
    public MinStack() {
        top = new Node();
    }
    
    public void push(int x) {
        int min=x;
        if(x&gt;top.min){
            min=top.min;
        }
        Node n = new Node(x,min);
        n.next = top;
        top = n;
    }
    
    public void pop() {
        top = top.next;
    }
    
    public int top() {
        return top.value;
    }
    
    public int getMin() {
        // int min = top.value;
        // Node n = top;
        // while(n.next!=null){
        //     n = n.next;
        //     if(n.value&lt;min){
        //         min = n.value;
        //     }
        // }
        return top.min;
    }
}
class Node{
    int value;
    Node next;
    int min;
    Node(){
        this.value=Integer.MAX_VALUE;
        this.min=Integer.MAX_VALUE;
    }
    Node(int x,int min){
        this.value = x;
        this.min = min;
    }
    
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vscode远程连接linux遇到的问题]]></title>
        <id>https://oneseek.github.io/post/vscode-yuan-cheng-lian-jie-linux-yu-dao-de-wen-ti/</id>
        <link href="https://oneseek.github.io/post/vscode-yuan-cheng-lian-jie-linux-yu-dao-de-wen-ti/">
        </link>
        <updated>2020-04-11T14:10:55.000Z</updated>
        <content type="html"><![CDATA[<p>输密码能连上密钥连不上，验证密钥的时候发现有个提示，点开提示里的detile，说是权限太大，删除其他用户的权限就能用密钥了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[17.18. 最短超串]]></title>
        <id>https://oneseek.github.io/post/1718-zui-duan-chao-chuan/</id>
        <link href="https://oneseek.github.io/post/1718-zui-duan-chao-chuan/">
        </link>
        <updated>2020-04-10T14:22:11.000Z</updated>
        <content type="html"><![CDATA[<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<p>示例 1:</p>
<p>输入:<br>
big = [7,5,9,0,2,1,3,5,7,9,1,1,5,8,8,9,7]<br>
small = [1,5,9]<br>
输出: [7,10]<br>
示例 2:</p>
<p>输入:<br>
big = [1,2,3]<br>
small = [4]<br>
输出: []<br>
提示：</p>
<p>big.length &lt;= 100000<br>
1 &lt;= small.length &lt;= 100000</p>
<pre><code>class Solution {
    public int[] shortestSeq(int[] big,int[] small) {
        if(small.length&gt;big.length){ //small长度大于big的情况
            return new int[0];
        }
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        int count = small.length;
        int[] ans = {0,big.length};

        for(int i:small){
            map.put(i, -1);
        }

        for(int i=0;i&lt;big.length;i++){
            if(map.containsKey(big[i])){
                if(map.get(big[i])==-1){
                    count--;
                }
                map.put(big[i], i);
            }
            if(count&lt;=0){
                Object[] objects =  map.values().toArray();
                int minNum = getMin(objects);
                if(i-minNum+1&lt;ans[1]-ans[0]+1){
                    ans[0]=minNum;
                    ans[1]=i;
                }
            }
            if(count&gt;0&amp;&amp;big.length-1==i){ // 查找不到超短字串的情况
                ans=new int[0];
            }
        }

        return ans;
    }

    int getMin(Object[] obj) {
        int minNum = Integer.MAX_VALUE;
        for(Object i:obj){
            minNum=Math.min((int)i, minNum);
        }
        return minNum;
    }
}
</code></pre>
<p><a href="https://leetcode-cn.com/problems/shortest-supersequence-lcci/solution/chao-xiang-xi-jie-fa-yi-ding-neng-kan-dong-by-yuan/">题目链接</a></p>
]]></content>
    </entry>
</feed>