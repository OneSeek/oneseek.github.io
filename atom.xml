<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-19T02:34:15.654Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[nginx 资源重定向错误]]></title>
        <id>https://oneseek.github.io/post/nginx-zi-yuan-chong-ding-xiang-cuo-wu/</id>
        <link href="https://oneseek.github.io/post/nginx-zi-yuan-chong-ding-xiang-cuo-wu/">
        </link>
        <updated>2020-03-18T13:12:34.000Z</updated>
        <content type="html"><![CDATA[<p>原因 leanote 页面使用的是绝对 路径 导致 二级目录访问 会跳转到 根目录<br>
例如 localhost/leanote/index 变成 localhost/index</p>
<p>解决方法：<br>
用sub_filter 将请求的资源变成 相对路径<br>
可能会造成从第三方网址的资源不可用 但是暂时只能这样解决了</p>
<pre><code>sub_filter 'src=&quot;/' 'src=&quot;./'; 
sub_filter 'href=&quot;/' 'href=&quot;./'; 
 sub_filter_once off;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nginx 反向代理]]></title>
        <id>https://oneseek.github.io/post/nginx-sub_filter/</id>
        <link href="https://oneseek.github.io/post/nginx-sub_filter/">
        </link>
        <updated>2020-03-18T05:30:18.000Z</updated>
        <content type="html"><![CDATA[<p>配置leanote时，希望把二级目录 匹配到端口 发现只能进首页其他的url都不对</p>
<p>原因：连接没有重定向到 二级目录下</p>
<p>增加 sub_filter 属性能让首页的资源加载到 但是点击连接别的页面 却被从定向到根目录</p>
<pre><code>listen 80;
        server_name localhost;

        location /leanote/ {
            proxy_pass http://localhost:9000/;
            sub_filter / /leanote;
        }
</code></pre>
<p>解决： 使用代理 把资源匹配到正确路径</p>
<pre><code>location / {
         proxy_pass http://localhost:9000/;
        }
        location /leanote/ {
            proxy_pass http://localhost:9000/;
        }
}
</code></pre>
<p>但是这样</p>
<p>参考文章 ： https://blog.csdn.net/djfjkj52/article/details/96426979</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS7 搭建leanote]]></title>
        <id>https://oneseek.github.io/post/centos7-da-jian-leanote/</id>
        <link href="https://oneseek.github.io/post/centos7-da-jian-leanote/">
        </link>
        <updated>2020-03-17T11:22:02.000Z</updated>
        <content type="html"><![CDATA[<p>1、leanote官网下载二进制文件<br>
2、mongodb下载<br>
3、mongodb配置<br>
4、leanote配置<br>
5、nginx反代</p>
<p>下载leanote linux 二进制文件 https://sourceforge.net/projects/leanote-bin/files/2.6.1/leanote-linux-amd64-v2.6.1.bin.tar.gz/download</p>
<p>https://github.com/leanote/leanote/wiki/Leanote-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%88%E8%AF%A6%E7%BB%86%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B----Mac-and-Linux</p>
<p>照着做就完了。。。。</p>
<p>二级目录反向代理</p>
<pre><code>server
    {

        listen 80;   
        server_name learn.oneseek.cn;

        location /leanote/ {
            proxy_pass http://localhost:9000/;
        }

    }
</code></pre>
<p>访问 learn.oneseek.cn/learn 进入9000端口的网站</p>
<p>启动mongo命令<br>
mongod --dbpath /home/user1/data<br>
启动leanote<br>
bash run.sh</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阶乘 第一个不是零的数字]]></title>
        <id>https://oneseek.github.io/post/jie-cheng-di-yi-ge-bu-shi-ling-de-shu-zi/</id>
        <link href="https://oneseek.github.io/post/jie-cheng-di-yi-ge-bu-shi-ling-de-shu-zi/">
        </link>
        <updated>2020-03-16T13:56:25.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*试题 算法训练 P0505

资源限制
时间限制：1.0s   内存限制：256.0MB
　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13！就已经比较大了，已经无法存放在一个整型变量中；而35！就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5！=1*2*3*4*5=120，因此5!最右边的那个非0的数字是2。再如，7！=5040，因此7！最右边的那个非0的数字是4。再如，15！=
1307674368000，因此15！最右边的那个非0的数字是8。请编写一个程序，输入一个整数n(0&lt;n&lt;=100)，然后输出n!最右边的那个非0的数字是多少。
输入：
　　7
输出：
　　4
*/
#include &lt;iostream&gt;
using namespace std;
int delZero(int i) {
    while (i % 10 == 0) {
        i /= 10;
    };
    return i;
}
int main() {
    int n;
    cin &gt;&gt; n;
    int ans = 1;;
    for (int i = 1; i &lt;= n; i++) {
        ans *= i;
        ans = delZero(ans);
        ans = ans % 1000;
    }
    cout &lt;&lt;ans%10;
    return 0;
}
</code></pre>
<h2 id="因为这道题n的范围是-n100-所以对1000求余是可以得出正确答案的如果更大可以用数组模拟乘法来做">因为这道题n的范围是 n&lt;100 所以对1000求余是可以得出正确答案的，如果更大可以用数组模拟乘法来做</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int a[10005];
int main() {
    long n;
    memset(a, 0, sizeof(a));
    cin &gt;&gt; n;
    a[0] = 1;
    int s, c = 0;  // c 进位
    for (int i = 2; i &lt;= n; i++) {
        for (int j = 0; j &lt; 10000; j++) {
            s = a[j] * i + c;
            a[j] = s % 10;
            c = s / 10;
        }
    }
    for (int i = 0;; i++) {
        if (a[i] != 0) {
            cout &lt;&lt; a[i];
            break;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-万万没想到之抓捕孔连顺]]></title>
        <id>https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-zhua-bu-kong-lian-shun/</id>
        <link href="https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-zhua-bu-kong-lian-shun/">
        </link>
        <updated>2020-03-15T11:28:34.000Z</updated>
        <content type="html"><![CDATA[<p>排列组合公式<br>
<img src="https://oneseek.github.io/post-images/1584271775556.png" alt="" loading="lazy"></p>
<pre><code>/*
[编程题]万万没想到之抓捕孔连顺
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 128M，其他语言256M

我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议

1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。
2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

我特喵是个天才!
经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！
……
万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！

请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。
注意：
1. 两个特工不能埋伏在同一地点
2. 三个特工是等价的：即同样的位置组合(A, B, C)
只算一种埋伏方法，不能因“特工之间互换位置”而重复使用


输入描述:
第一行包含空格分隔的两个数字 N和D(1?≤?N?≤?1000000; 1?≤?D?≤?1000000)

第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0,
1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）

输出描述:
一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

输入例子1:
4 3
1 2 3 4

输出例子1:
4

例子说明1:
可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)

输入例子2:
5 19
1 10 20 30 50

输出例子2:
1

例子说明2:
可选方案 (1, 10, 20)
*/
#include &lt;iostream&gt;
using namespace std;

int main() {
    long long N, D, count = 0;
    cin &gt;&gt; N &gt;&gt; D;
    long long v[N];
    
    int j = 0;
    for (int i = 0; i &lt; N; i++) {
        cin &gt;&gt; v[i];

        while (v[i] - v[j] &gt; D&amp;&amp;i&gt;2) {
            j++;
        }
        long long c = i - j;
        count += (c - 1) * c / 2;

    }

    
    cout &lt;&lt; count % 99997867;

    return 0;
}

</code></pre>
]]></content>
    </entry>
</feed>