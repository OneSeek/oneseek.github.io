<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-04-10T12:59:25.610Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[leetcode 945. 使数组唯一的最小增量]]></title>
        <id>https://oneseek.github.io/post/leetcode-945-shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang/</id>
        <link href="https://oneseek.github.io/post/leetcode-945-shi-shu-zu-wei-yi-de-zui-xiao-zeng-liang/">
        </link>
        <updated>2020-04-08T14:41:22.000Z</updated>
        <content type="html"><![CDATA[<p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p>
<p>返回使 A 中的每个值都是唯一的最少操作次数。</p>
<p>示例 1:</p>
<p>输入：[1,2,2]<br>
输出：1<br>
解释：经过一次 move 操作，数组将变为 [1, 2, 3]。<br>
示例 2:</p>
<p>输入：[3,2,1,2,1,7]<br>
输出：6<br>
解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。<br>
可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。<br>
提示：</p>
<p>0 &lt;= A.length &lt;= 40000<br>
0 &lt;= A[i] &lt; 40000</p>
<p>思路：先排序，再去重复</p>
<pre><code>class Solution {
    public int minIncrementForUnique(int[] A) {
        int ans = 0;
        Arrays.sort(A);  
        for(int i=1;i&lt;A.length;i++){
            if(A[i]&lt;=A[i-1]){
                ans += A[i-1]+1-A[i];
                A[i]=A[i-1]+1;
            }
        }
        return ans;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 创建对象的几种方法]]></title>
        <id>https://oneseek.github.io/post/java-chuang-jian-dui-xiang-de-ji-chong-fang-fa/</id>
        <link href="https://oneseek.github.io/post/java-chuang-jian-dui-xiang-de-ji-chong-fang-fa/">
        </link>
        <updated>2020-04-06T03:11:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="正向">正向</h1>
<p>通过 new</p>
<h1 id="反向-反射">反向 -- 反射</h1>
<p>newInstant()<br>
使用Class类的newInstance方法<br>
使用Constructor类的newInstance方法</p>
<h1 id="clone">clone</h1>
<pre><code> implements Cloneable
</code></pre>
<h1 id="序列化">序列化</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java实现多线程的三种方法]]></title>
        <id>https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/</id>
        <link href="https://oneseek.github.io/post/java-shi-xian-duo-xian-cheng-de-san-chong-fang-fa/">
        </link>
        <updated>2020-04-06T02:53:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="第一种-继承-thread类">第一种 继承 Thread类</h2>
<pre><code> 继承Thread类，并重写Thread中的run方法
</code></pre>
<pre><code>class MyThread extends Thread{
　　@Override
　　public void run(){
 　　　　System.out.println(&quot;创建多线程方法一&quot;);
　　}
}
</code></pre>
<h2 id="第二种-实现-runable接口">第二种 实现 Runable接口</h2>
<pre><code>      实现Runnable接口，重写run()方法
</code></pre>
<pre><code>class MyThread implements Runnable{
     @Override
     public void run(){
         System.out.println(&quot;创建多线程方法二&quot;);
     }
}
</code></pre>
<h2 id="第三种-实现callable接口">第三种 实现Callable接口</h2>
<pre><code>      实现Callable接口，重写call()方法
      可以提供返回值 可以抛出异常
      创建Callable实现类
      创建线程池 submi Callable实现类t
</code></pre>
<pre><code>
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见关系数据库和非关系数据库]]></title>
        <id>https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/</id>
        <link href="https://oneseek.github.io/post/chang-jian-guan-xi-shu-ju-ku-he-fei-guan-xi-shu-ju-ku/">
        </link>
        <updated>2020-04-06T02:52:33.000Z</updated>
        <content type="html"><![CDATA[<p>​关系数据库 ：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL</p>
<p>​非关系数据库：NoSql、Cloudant、MongoDb、redis、HBase</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[岛屿数量]]></title>
        <id>https://oneseek.github.io/post/dao-yu-shu-liang/</id>
        <link href="https://oneseek.github.io/post/dao-yu-shu-liang/">
        </link>
        <updated>2020-04-05T13:43:17.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p>
<p>示例 1:</p>
<p>输入:<br>
11110<br>
11010<br>
11000<br>
00000</p>
<p>输出: 1<br>
示例 2:</p>
<p>输入:<br>
11000<br>
11000<br>
00100<br>
00011</p>
<p>输出: 3</p>
<pre><code>class Solution {
    public int numIslands(char[][] grid) {
        int nums = 0;
        int h = grid.length;
        int w = grid.length&gt;0?grid[0].length:0;
        for(int i=0;i&lt;h;i++){
            for(int j=0;j&lt;w;j++){
                System.out.print(grid[i][j]+&quot; &quot;);
                if(grid[i][j]=='1'){
                    nums++;
                    dfs(i,j,grid);
                }
            }
            System.out.println();
        }
        return nums;
    }
    
    void dfs(int i,int j,char[][] grid){
        grid[i][j]='0';
        if(j&lt;grid[0].length-1){
            if(grid[i][j+1]=='1'){
                grid[i][j+1]='0';
                dfs(i,j+1,grid);
            }  
        }
        if(i&lt;grid.length-1){
            if(grid[i+1][j]=='1'){
                grid[i+1][j]='0';
                dfs(i+1,j,grid);
            }  
        }
        if(i&gt;0){
            if(grid[i-1][j]=='1'){
                grid[i-1][j]='0';
                dfs(i-1,j,grid);
            }  
        }
        if(j&gt;0){
            if(grid[i][j-1]=='1'){
                grid[i][j-1]='0';
                dfs(i,j-1,grid);
            }  
        }
        
    }
}
</code></pre>
<!-- more -->第二遍
<pre><code>class Solution {
    public int numIslands(char[][] grid) {
        int num=0;
        for(int i=0;i&lt;grid.length;i++){
            for(int j=0;j&lt;grid[0].length;j++){
                if(grid[i][j]=='1'){
                    dfs(i,j,grid);
                    num++;
                }
            }   
        }
        return num;
    }
    public void dfs(int i,int j,char[][] grid){
        grid[i][j]='0';
        if(i&lt;grid.length-1&amp;&amp;grid[i+1][j]=='1'){
            dfs(i+1,j,grid);
        }
        if(j&lt;grid[0].length-1&amp;&amp;grid[i][j+1]=='1'){
            dfs(i,j+1,grid);
        }
        if(i&gt;0&amp;&amp;grid[i-1][j]=='1'){
            dfs(i-1,j,grid);
        }
        if(j&gt;0&amp;&amp;grid[i][j-1]=='1'){
            dfs(i,j-1,grid);
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>