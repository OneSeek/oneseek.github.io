<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://oneseek.github.io</id>
    <title>OneSeek</title>
    <updated>2020-03-17T10:14:13.110Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://oneseek.github.io"/>
    <link rel="self" href="https://oneseek.github.io/atom.xml"/>
    <subtitle>Be a coder who can change the world</subtitle>
    <logo>https://oneseek.github.io/images/avatar.png</logo>
    <icon>https://oneseek.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, OneSeek</rights>
    <entry>
        <title type="html"><![CDATA[阶乘 第一个不是零的数字]]></title>
        <id>https://oneseek.github.io/post/jie-cheng-di-yi-ge-bu-shi-ling-de-shu-zi/</id>
        <link href="https://oneseek.github.io/post/jie-cheng-di-yi-ge-bu-shi-ling-de-shu-zi/">
        </link>
        <updated>2020-03-16T13:56:25.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*试题 算法训练 P0505

资源限制
时间限制：1.0s   内存限制：256.0MB
　　一个整数n的阶乘可以写成n!，它表示从1到n这n个整数的乘积。阶乘的增长速度非常快，例如，13！就已经比较大了，已经无法存放在一个整型变量中；而35！就更大了，它已经无法存放在一个浮点型变量中。因此，当n比较大时，去计算n!是非常困难的。幸运的是，在本题中，我们的任务不是去计算n!，而是去计算n!最右边的那个非0的数字是多少。例如，5！=1*2*3*4*5=120，因此5!最右边的那个非0的数字是2。再如，7！=5040，因此7！最右边的那个非0的数字是4。再如，15！=
1307674368000，因此15！最右边的那个非0的数字是8。请编写一个程序，输入一个整数n(0&lt;n&lt;=100)，然后输出n!最右边的那个非0的数字是多少。
输入：
　　7
输出：
　　4
*/
#include &lt;iostream&gt;
using namespace std;
int delZero(int i) {
    while (i % 10 == 0) {
        i /= 10;
    };
    return i;
}
int main() {
    int n;
    cin &gt;&gt; n;
    int ans = 1;;
    for (int i = 1; i &lt;= n; i++) {
        ans *= i;
        ans = delZero(ans);
        ans = ans % 1000;
    }
    cout &lt;&lt;ans%10;
    return 0;
}
</code></pre>
<h2 id="因为这道题n的范围是-n100-所以对1000求余是可以得出正确答案的如果更大可以用数组模拟乘法来做">因为这道题n的范围是 n&lt;100 所以对1000求余是可以得出正确答案的，如果更大可以用数组模拟乘法来做</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
int a[10005];
int main() {
    long n;
    memset(a, 0, sizeof(a));
    cin &gt;&gt; n;
    a[0] = 1;
    int s, c = 0;  // c 进位
    for (int i = 2; i &lt;= n; i++) {
        for (int j = 0; j &lt; 10000; j++) {
            s = a[j] * i + c;
            a[j] = s % 10;
            c = s / 10;
        }
    }
    for (int i = 0;; i++) {
        if (a[i] != 0) {
            cout &lt;&lt; a[i];
            break;
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-万万没想到之抓捕孔连顺]]></title>
        <id>https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-zhua-bu-kong-lian-shun/</id>
        <link href="https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-zhua-bu-kong-lian-shun/">
        </link>
        <updated>2020-03-15T11:28:34.000Z</updated>
        <content type="html"><![CDATA[<p>排列组合公式<br>
<img src="https://oneseek.github.io/post-images/1584271775556.png" alt="" loading="lazy"></p>
<pre><code>/*
[编程题]万万没想到之抓捕孔连顺
时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 128M，其他语言256M

我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议

1. 我们在字节跳动大街的N个建筑中选定3个埋伏地点。
2. 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。

我特喵是个天才!
经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！
……
万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！

请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。
注意：
1. 两个特工不能埋伏在同一地点
2. 三个特工是等价的：即同样的位置组合(A, B, C)
只算一种埋伏方法，不能因“特工之间互换位置”而重复使用


输入描述:
第一行包含空格分隔的两个数字 N和D(1?≤?N?≤?1000000; 1?≤?D?≤?1000000)

第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0,
1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴）

输出描述:
一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模

输入例子1:
4 3
1 2 3 4

输出例子1:
4

例子说明1:
可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)

输入例子2:
5 19
1 10 20 30 50

输出例子2:
1

例子说明2:
可选方案 (1, 10, 20)
*/
#include &lt;iostream&gt;
using namespace std;

int main() {
    long long N, D, count = 0;
    cin &gt;&gt; N &gt;&gt; D;
    long long v[N];
    
    int j = 0;
    for (int i = 0; i &lt; N; i++) {
        cin &gt;&gt; v[i];

        while (v[i] - v[j] &gt; D&amp;&amp;i&gt;2) {
            j++;
        }
        long long c = i - j;
        count += (c - 1) * c / 2;

    }

    
    cout &lt;&lt; count % 99997867;

    return 0;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[leetcode-万万没想到之聪明的编辑]]></title>
        <id>https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-cong-ming-de-bian-ji/</id>
        <link href="https://oneseek.github.io/post/leetcode-wan-wan-mei-xiang-dao-zhi-cong-ming-de-bian-ji/">
        </link>
        <updated>2020-03-15T11:01:59.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
[编程题]万万没想到之聪明的编辑

时间限制：C/C++ 1秒，其他语言2秒

空间限制：C/C++ 32M，其他语言64M

我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径：

1. 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello
2. 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello
3. 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC

我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！
……
万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的……

请听题：请实现大锤的自动校对程序

输入描述:
第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。

后面跟随N行，每行为一个待校验的字符串。

输出描述:
N行，每行包括一个被修复后的字符串。

输入例子1:
2
helloo
wooooooow

输出例子1:
hello
woow
*/
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
//hello
string strhandle(string m) {
    string n = &quot;&quot;;
    for (int i = 0; i &lt; m.length(); i++) {
        if (m[i] == m[i + 1] &amp;&amp; m[i + 2] == m[i + 3]&amp;&amp; i+3&lt;m.length()) {
            n += m[i];
            n += m[i + 1];
            n += m[i + 2];
            i += 3;
        }else{
            n += m[i];
        }
    }
    return n;
}
string strhandle2(string x) {
    // wooooow
    string m = &quot;&quot;;
    for (int i = 0; i &lt; x.length(); i++) {
        if (x[i] == x[i + 1] &amp;&amp; x[i + 1] == x[i + 2]) {
            
        }else{
            m += x[i];
        }
    }
    // aabb
    return strhandle(m);
}

int main() {
    int N;
    cin &gt;&gt; N;

    for (int i = 0; i &lt; N; i++) {
        string x;
        cin &gt;&gt; x;

        cout &lt;&lt; strhandle2(x) &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot 启动类 @SpringBootApplication 属性]]></title>
        <id>https://oneseek.github.io/post/springboot-qi-dong-lei-springbootapplication-shu-xing/</id>
        <link href="https://oneseek.github.io/post/springboot-qi-dong-lei-springbootapplication-shu-xing/">
        </link>
        <updated>2020-03-15T08:05:16.000Z</updated>
        <content type="html"><![CDATA[<h3 id="给学院做的一个项目访问404发现是一个学弟在springbootapplication这多加了一个属性-scanbasepackages在解决问题的过程中发现自己也有很多东西都不了解记录一下">给学院做的一个项目访问404，发现是一个学弟在@SpringBootApplication这多加了一个属性 scanBasePackages，在解决问题的过程中发现自己也有很多东西都不了解，记录一下</h3>
<p>SpringBoot官方文档中对@SpringBootApplication 的解释<br>
@SpringBootApplication 注解相当于使用 @Configuration、@EnableAutoConfiguration 和 @ComponentScan</p>
<p>@SpringBootApplication 还提供了别名来自定义 @EnableAutoConfiguration 和 @ComponentScan 的属性。</p>
<p>@EnableAutoConfiguration：启用Spring Boot的自动配置机制，类似在java代码中自动import，属于自动导入。</p>
<p>@Configuration：有自动导入就有属于自动导出，需要配合该类中方法的@bean，这就相当于一个xml配置:</p>
<p>@ComponentScan：扫描所有使用@Component 的类，不管自动导入还是导出，首先需要告诉spring boot到哪里去找导入导出的原料。</p>
<p>scanBasePackages是 ComponentScan的一个属性</p>
<p>ComponentScan注解里有两种方式用来指定扫描的范围:<br>
一、scanBasePackages (常用)<br>
可以指定多个包名进行扫描<br>
二、scanBasePackageClasses<br>
可以指定多个类或接口的class,扫描时会 在这些指定的类和接口所属的包进行扫面。</p>
<p>@SpringBootApplication 源码</p>
<pre><code>//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package org.springframework.boot.autoconfigure;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.boot.SpringBootConfiguration;
import org.springframework.boot.context.TypeExcludeFilter;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;
import org.springframework.context.annotation.ComponentScan.Filter;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    @AliasFor(
        annotation = EnableAutoConfiguration.class
    )
    Class&lt;?&gt;[] exclude() default {};

    @AliasFor(
        annotation = EnableAutoConfiguration.class
    )
    String[] excludeName() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = &quot;basePackages&quot;
    )
    String[] scanBasePackages() default {};

    @AliasFor(
        annotation = ComponentScan.class,
        attribute = &quot;basePackageClasses&quot;
    )
    Class&lt;?&gt;[] scanBasePackageClasses() default {};

    @AliasFor(
        annotation = Configuration.class
    )
    boolean proxyBeanMethods() default true;
}

</code></pre>
<p>这里面的类关系往往是一个里面有其他更多的配置 所以等以后有时间做个思维导图把他们的关系表示出来</p>
<pre><code>参考文档 SpringBoot官方文档
知乎 https://zhuanlan.zhihu.com/p/60421014
csdn https://blog.csdn.net/qq_28163175/article/details/89194108
Spring零配置之@Configuration注解详解。 https://mp.weixin.qq.com/s/i8qHLkdtf4XzRyIRJ8R_7A
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真题-特别数的和]]></title>
        <id>https://oneseek.github.io/post/zhen-ti-te-bie-shu-de-he/</id>
        <link href="https://oneseek.github.io/post/zhen-ti-te-bie-shu-de-he/">
        </link>
        <updated>2020-03-14T13:54:58.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
第六题
标题：特别数的和（时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分）###
【问题描述】
小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0） ，在 1 到
40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。
请问，在 1 到 n 中，所有这样的数的和是多少？
【输入格式】
输入一行包含两个整数 n。
【输出格式】
输出一行，包含一个整数，表示满足条件的数的和。
【样例输入】
40
【样例输出】
574
【评测用例规模与约定】
对于 20% 的评测用例，1 ≤ n ≤ 10。
对于 50% 的评测用例，1 ≤ n ≤ 100。
对于 80% 的评测用例，1 ≤ n ≤ 1000。
对于所有评测用例，1 ≤ n ≤ 10000。*/
#include &lt;iostream&gt;
using namespace std;
bool judge(int i) {
    while (i) {
        if (i % 10 == 2 || i % 10 == 0 || i % 10 == 1 || i % 10 == 9) {
            return true;
        }
        i /= 10;
    }
    return false;
}
int main() {
    int n;
    cin &gt;&gt; n;
    int ans = 0;
    for (int i = 1; i &lt;= n; i++) {
        if (judge(i)) {
            ans += i;
        }
    }
    cout &lt;&lt; ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真题-数列求值]]></title>
        <id>https://oneseek.github.io/post/zhen-ti-shu-lie-qiu-zhi/</id>
        <link href="https://oneseek.github.io/post/zhen-ti-shu-lie-qiu-zhi/">
        </link>
        <updated>2020-03-14T13:38:11.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
标题：数列求值 （本题总分：10 分）###
给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求
第 20190324 项的最后 4 位数字。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个 4 位整数（提示：答案的千位不为 0） ，在提交答案时只填写这个整数，填写
多余的内容将无法得分。*/
#include &lt;iostream&gt;
using namespace std;

int main() {
    int a[4];
    a[1] = 1;
    a[2] = 1;
    a[3] = 1;
    int m;
    for (int i = 4; i &lt;= 20190324; i++) {
        m = a[1] + a[2] + a[3];
        m %= 10000;
        a[1] = a[2];
        a[2] = a[3];
        a[3] = m;
        
    }
    cout &lt;&lt; a[3];
    return 0;
}
</code></pre>
<p>这两道题都是简单题但是也有一些细节需要注意，还得多练这种题做起来都没有很顺利。。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[真题-数的分解]]></title>
        <id>https://oneseek.github.io/post/zhen-ti-shu-de-fen-jie/</id>
        <link href="https://oneseek.github.io/post/zhen-ti-shu-de-fen-jie/">
        </link>
        <updated>2020-03-14T13:37:21.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
标题： 数的分解（本题总分：10 分）
【问题描述】
把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包
含数字 2 和 4，一共有多少种不同的分解方法？
注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和
1001+1000+18 被视为同一种。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分*/
#include &lt;iostream&gt;
using namespace std;
bool judge(int i) {
    while (i) {
        if (i % 10 == 2 || i % 10 == 4)
            return false;
        i /= 10;
    }
    return true;
}
int main() {
    int ans = 0;
    for (int i = 1; i &lt;= 672; i++) {
        if (judge(i))
            for (int j = i + 1; j &lt;= 1008; j++) {
                if (judge(j))
                    for (int k = j + 1; k &lt;= 1999; k++) {
                        if (judge(k))
                            if (i + j + k == 2019) {
                                // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;
                                ans++;
                            }
                    }
            }
    }

    cout &lt;&lt; ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS7安装桌面环境（腾讯云)]]></title>
        <id>https://oneseek.github.io/post/centos7-yi-jian-an-zhuang-zhuo-mian-huan-jing-teng-xun-yun/</id>
        <link href="https://oneseek.github.io/post/centos7-yi-jian-an-zhuang-zhuo-mian-huan-jing-teng-xun-yun/">
        </link>
        <updated>2020-03-12T01:38:35.000Z</updated>
        <content type="html"><![CDATA[<p>腾讯云快到期了 作一把(●'◡'●)</p>
<p>参考文章 https://cloud.tencent.com/developer/article/1350824<br>
https://www.jianshu.com/p/63dce85dc958</p>
<p>安装X(X Window System)，命令如下：<br>
yum groupinstall &quot;X Window System&quot;<br>
安装图形界面软件，GNOME(GNOME Desktop)，命令如下：<br>
yum groupinstall &quot;GNOME Desktop&quot;</p>
<h2 id="安装配置xrdp">安装配置XRDP</h2>
<p>下面的很多操作需要root用户权限，所以，我们先切换为root用户：</p>
<p>sudo su - root<br>
安装epel库<br>
查询是否已经安装epel库:</p>
<p>rpm -qa|grep epel<br>
如果 epel库 没有安装，则安装它：</p>
<p>yum install epel-release<br>
安装xrdp<br>
安装xrdp服务：</p>
<p>yum install xrdp<br>
因为Xrdp最终会自动启用VNC，所以必须安装tigervnc-server，否则xrdp无法使用。安装vnc：</p>
<p>yum install tigervnc-server<br>
为root用户设置VNC密码：</p>
<p>vncpasswd root<br>
修改 xrdp最大连接数（使用默认值，不修改也是可以的） ：vim /etc/xrdp/xrdp.ini （默认是32）：</p>
<p>max_bpp=32<br>
xrdp最大连接数设置<br>
关闭防火墙<br>
这里，我们要确保两台机器可以ping通，能够相互访问。我这里是在局域网内测试，所以我直接关闭防火墙：</p>
<p>systemctl stop firewalld.service<br>
设置开机不启动防火墙：</p>
<p>systemctl disable firewalld.servie<br>
关闭SElinux<br>
SElinux应该关闭它。查看SElinux状态：</p>
<p>sestatus<br>
如果是临时关闭SElinux：</p>
<p>setenforce 0<br>
不过，我们要永久关闭SElinux：vim /etc/selinux/config</p>
<p>SELINUX=disabled<br>
永久关闭SELINUX<br>
启动XRDP<br>
启动xrdp服务：</p>
<p>systemctl start xrdp<br>
设置xrdp服务 开机自启动 ：</p>
<p>systemctl enable xrdp<br>
<img src="https://oneseek.github.io/post-images/1584066517857.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-动态数组]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-dong-tai-shu-zu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-dong-tai-shu-zu/">
        </link>
        <updated>2020-03-11T13:41:51.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 动态数组使用
  
资源限制
时间限制：1.0s   内存限制：512.0MB
从键盘读入n个整数，使用动态数组存储所读入的整数，并计算它们的和与平均值分别输出。要求尽可能使用函数实现程序代码。平均值为小数的只保留其整数部分。
样例输入: 
5 
3 4 0 0 2
样例输出:
9  1
样例输入: 
7
3 2 7 5 2 9 1
样例输出:
29  4
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
using namespace std;
int getSum(vector&lt;int&gt; arr){
	int sum=0;
	for(int i=0;i&lt;arr.size();i++){
		sum+=arr[i];
	}
	return sum;
} 
int main() {
    int n;
    vector&lt;int&gt; arr;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0;i&lt;n;i++){
		int x;
		scanf(&quot;%d&quot;,&amp;x);
		arr.push_back(x);
	}
	
	int sum = getSum(arr);
	int avg = sum/arr.size();
	printf(&quot;%d %d&quot;,sum,avg);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法训练-1的个数]]></title>
        <id>https://oneseek.github.io/post/suan-fa-xun-lian-1-de-ge-shu/</id>
        <link href="https://oneseek.github.io/post/suan-fa-xun-lian-1-de-ge-shu/">
        </link>
        <updated>2020-03-11T13:26:27.000Z</updated>
        <content type="html"><![CDATA[<pre><code>/*
试题 算法训练 1的个数
  
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
　　输入正整数n，判断从1到n之中，数字1一共要出现几次。例如1123这个数，则出现了两次1。例如15，那么从1到15之中，一共出现了8个1。
输入格式
　　一个正整数n
输出格式
　　一个整数，表示1出现的资料
样例输入
15
样例输出
8
数据规模和约定
　　n不超过30000
*/
#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
int cal(int n){
	int sum=0;
	while(n){
		if(n%10==1){
			sum++;
		}
		n/=10;
	}
	return sum;
} 
int main() {
    int n;
    scanf(&quot;%d&quot;,&amp;n);
	int sum=0;
	for(int i=1;i&lt;=n;i++){
		sum+=cal(i);
	}
	printf(&quot;%d&quot;,sum);
    return 0;
}
</code></pre>
<h3 id="水题刷着好开心啊o-̄-̄ブ">水题刷着好开心啊o(<em>￣▽￣</em>)ブ</h3>
]]></content>
    </entry>
</feed>